!SESSION 2021-04-06 13:52:45.668 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-06 13:52:56.747
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-06 13:52:56.747
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@13f4048e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5477d90e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-06 13:53:21.672
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-06 13:54:39.909 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data E:\AYUSH\Programming\J2 -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-06 13:54:52.124
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-06 13:54:52.124
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e4f2300,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e706aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-06 13:55:00.553
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-06 13:57:41.397 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data file:/E:/AYUSH/Programming/J2/ -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-06 13:57:53.210
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-06 13:57:53.210
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@48ee3c2d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54387873,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-06 13:58:05.994
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2021-04-06 14:06:52.870
!MESSAGE close() called when useCnt is already zero for Repository[E:\AYUSH\Programming\J2\.git]
!SESSION 2021-04-06 14:08:07.032 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-06 14:08:19.287
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-06 14:08:19.287
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@311d28f5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@569a26ab,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-06 14:08:47.926
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.core 4 0 2021-04-06 14:08:52.525
!MESSAGE Remove repository mapping of Git mapped resource for which project or mapped git repository has disappeared: 'RepositoryMapping[<empty> -> '../.git', absolute path: 'E:/AYUSH/Programming/J2/.git' ]'
!STACK 0
java.io.FileNotFoundException: 
	at org.eclipse.egit.core.project.GitProjectData.logAndUnmapGoneMappedResource(GitProjectData.java:728)
	at org.eclipse.egit.core.project.GitProjectData.map(GitProjectData.java:691)
	at org.eclipse.egit.core.project.GitProjectData.remapAll(GitProjectData.java:655)
	at org.eclipse.egit.core.project.GitProjectData.load(GitProjectData.java:638)
	at org.eclipse.egit.core.project.GitProjectData.get(GitProjectData.java:221)
	at org.eclipse.egit.core.project.RepositoryMapping.getProjectData(RepositoryMapping.java:335)
	at org.eclipse.egit.core.project.RepositoryMapping.findMapping(RepositoryMapping.java:356)
	at org.eclipse.egit.core.project.RepositoryMapping.getMapping(RepositoryMapping.java:296)
	at org.eclipse.egit.core.internal.util.ResourceUtil.getRepository(ResourceUtil.java:709)
	at org.eclipse.egit.ui.internal.resources.ResourceStateFactory.getIndexDiffDataOrNull(ResourceStateFactory.java:103)
	at org.eclipse.egit.ui.internal.decorators.GitLightweightDecorator.decorateResource(GitLightweightDecorator.java:192)
	at org.eclipse.egit.ui.internal.decorators.GitLightweightDecorator.decorate(GitLightweightDecorator.java:170)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:247)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.egit.core 4 0 2021-04-06 14:08:52.566
!MESSAGE Remove repository mapping of Git mapped resource for which project or mapped git repository has disappeared: 'RepositoryMapping[<empty> -> '../.git', absolute path: 'E:/AYUSH/Programming/J2/.git' ]'
!STACK 0
java.io.FileNotFoundException: 
	at org.eclipse.egit.core.project.GitProjectData.logAndUnmapGoneMappedResource(GitProjectData.java:728)
	at org.eclipse.egit.core.project.GitProjectData.map(GitProjectData.java:691)
	at org.eclipse.egit.core.project.GitProjectData.remapAll(GitProjectData.java:655)
	at org.eclipse.egit.core.project.GitProjectData.load(GitProjectData.java:638)
	at org.eclipse.egit.core.project.GitProjectData.get(GitProjectData.java:221)
	at org.eclipse.egit.core.project.RepositoryMapping.getProjectData(RepositoryMapping.java:335)
	at org.eclipse.egit.core.project.RepositoryMapping.findMapping(RepositoryMapping.java:356)
	at org.eclipse.egit.core.project.RepositoryMapping.getMapping(RepositoryMapping.java:296)
	at org.eclipse.egit.core.internal.util.ResourceUtil.getRepository(ResourceUtil.java:709)
	at org.eclipse.egit.ui.internal.resources.ResourceStateFactory.getIndexDiffDataOrNull(ResourceStateFactory.java:103)
	at org.eclipse.egit.ui.internal.decorators.GitLightweightDecorator.decorateResource(GitLightweightDecorator.java:192)
	at org.eclipse.egit.ui.internal.decorators.GitLightweightDecorator.decorate(GitLightweightDecorator.java:170)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:247)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-04-06 15:50:48.068 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-06 15:50:59.933
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-06 15:50:59.933
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6cde0c69,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f4d2294,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-06 15:51:14.855
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-11 20:22:09.849 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-11 20:22:27.579
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-11 20:22:27.579
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@22361e23,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2e0516a3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-11 20:22:53.369
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-27 19:28:29.839 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-27 19:28:45.475
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-27 19:28:45.476
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@57fce8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@77204651,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-27 19:29:11.478
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-04-28 19:26:10.021 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-04-28 19:26:25.841
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-04-28 19:26:25.842
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@72a33316,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@57fce8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-04-28 19:26:46.393
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-05-19 10:34:48.144 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-05-19 10:35:19.209
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-19 10:35:19.209
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2e0516a3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32a4ea4e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     !SESSION 2021-05-19 10:39:03.500 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2021-05-19 10:40:12.066
!MESSAGE Could not read metadata for 'E:\AYUSH\Programming\J2\.metadata\.plugins\org.eclipse.core.resources\.root\.indexes\properties.index'. Unexpected version: 0.

!ENTRY org.eclipse.jface 2 0 2021-05-19 10:40:32.321
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-19 10:40:32.321
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5256fbc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58f50dd0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-05-19 10:41:48.883
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.buildship.core 2 0 2021-05-19 10:41:52.732
!MESSAGE Could not load Gradle version information
!STACK 0
com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_ARRAY but was STRING at line 1 column 1 path $
	at com.google.gson.Gson.fromJson(Gson.java:944)
	at com.google.gson.Gson.fromJson(Gson.java:897)
	at com.google.gson.Gson.fromJson(Gson.java:846)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersions.create(PublishedGradleVersions.java:206)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersions.tryToReadUpToDateVersionsFile(PublishedGradleVersions.java:124)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersions.create(PublishedGradleVersions.java:114)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersionsWrapper$LoadVersionsJob.run(PublishedGradleVersionsWrapper.java:60)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.IllegalStateException: Expected BEGIN_ARRAY but was STRING at line 1 column 1 path $
	at com.google.gson.stream.JsonReader.beginArray(JsonReader.java:351)
	at com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter.read(CollectionTypeAdapterFactory.java:80)
	at com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter.read(CollectionTypeAdapterFactory.java:61)
	at com.google.gson.Gson.fromJson(Gson.java:932)
	... 7 more
!SESSION 2021-05-20 14:13:38.657 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-05-20 14:14:11.689
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-20 14:14:11.689
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@347b370c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26aee0a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-05-20 14:14:38.891
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-05-20 20:00:26.592 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-05-20 20:01:20.821
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-20 20:01:20.821
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35fb3209,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5855b0ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-05-20 20:01:51.755
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-05-21 11:22:25.543 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-05-21 11:22:53.270
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-21 11:22:53.270
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20184ade,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35fb3209,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-05-21 11:23:15.176
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-05-21 21:41:55.746 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-05-21 21:42:31.520
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-21 21:42:31.520
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32a4ea4e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@347b370c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-05-21 21:43:03.161
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-05-22 14:05:28.053 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-05-22 14:06:28.689
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-22 14:06:28.690
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26aee0a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20184ade,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-05-22 14:07:07.056
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-05-22 15:41:47.026 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-05-22 15:42:13.401
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2021-05-22 15:42:29.657
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-22 15:42:29.657
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5e7cd0df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@900649e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-05-22 15:43:12.282
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-05-22 17:09:47.710 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-05-22 17:10:05.186
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-22 17:10:05.186
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58f50dd0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3620eab,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-05-22 17:10:23.771
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-05-23 14:47:07.031 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-05-23 14:47:41.473
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2021-05-23 14:48:04.669
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-23 14:48:04.670
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6dd38df2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@99c3cee,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-05-23 14:48:43.684
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-05-24 16:54:27.150 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-05-24 16:55:05.210
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-24 16:55:05.210
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2619cb76,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@56f2c9e8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-05-24 16:55:33.278
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-05-25 19:32:06.940 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-05-25 19:33:15.458
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-05-25 19:33:15.458
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3620eab,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8ef1d58,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-05-25 19:34:40.652
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-02 16:34:11.596 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-02 16:34:35.201
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-02 16:34:35.201
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1dd44289,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6cc56b32,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-02 16:36:00.697
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-06-02 17:54:40.385
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package indexTools;

import java.util.*;
public class tandav {

	public static void main(String[] args) {
		     
//		int score;
//		int NUM_TESTS;
//		int sum = 0;
//
//		Scanner keyboard = new Scanner(System.in);
//		
//		System.out.println("Enter total number of test you have");
//		NUM_TESTS = keyboard.nextInt();
//		
//		for(int i = 1; i <= NUM_TESTS; ++i) {
//		
//			System.out.print("Enter the score on the test " + i + ": "); //prompt
//			score = keyboard.nextInt(); // read in the next integer
//			sum += score;
//		
//		}
//		keyboard.close();
//		
//		double AVERAGE;
//		AVERAGE = (sum) / (double) NUM_TESTS; // results
//		System.out.println("Your average is " + AVERAGE);

		
		
//		int odd = 0;
//		if(odd+1 > -1) System.out.println(odd);
		
/**
  	We will solve this question with wrost case in O(n) time complexity
   	and O(1) time complexity but before first look at an easy approch that is
   	using count sort. Using count sort we can solve this in O(n) time complexity
   	and O(n) time complexity
   	
   	What is count sort? 
   	It is linear algorithm, it does not make any comparisson to sort. 
   	It assumes that the number to be sorted is in range 1 to n.
   	
   	Let assume a unsorted array of 0s, 1s and 2s
   	where 0 = “Ice cream is too cold”, 1 = “Ice cream is just right”, 
   	2 = “Ice cream is melted".
   	
   	Create three variable named as "cold", "perfect" and "melted".
   	and traverse through the array and increment "cold" if array[i] == 0,
   	increment "perfect" if array[i] == 1 and increment "melted" if array[i] == 2.
   	
   	Now create another empty array of size N and fill it with the 0s, 1s and 2s using a for loop.
   	
   	Below code demonstrate the above explaination.
   	
   	
   	
   	
   	
   	
 */
		
		
		
		
		
		
		
		
		
		
		
		
	}
	
	public static int fn_sumInteger(int n) {
		if(n==0) return n;
		return n + fn_sumInteger(n-1);
	}
	
	public static void countSort(int arr())
	
	    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-06-02 17:54:40.485
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-06-02 17:54:40.487
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2021-06-16 14:03:29.200 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-16 14:03:57.221
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-16 14:03:57.221
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d297d4d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1dd44289,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-16 14:04:23.552
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-16 18:24:37.713 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-16 18:25:03.867
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-16 18:25:03.867
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@56f2c9e8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@457692cb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-16 18:25:34.408
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-23 10:23:10.308 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-23 10:23:32.904
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-23 10:23:32.904
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d297d4d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1dd44289,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-23 10:24:05.495
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-24 10:49:22.113 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-24 10:49:59.716
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-24 10:49:59.716
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@56f2c9e8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@457692cb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-24 10:50:29.399
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-06-27 20:06:32.598 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-06-27 20:07:03.318
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-06-27 20:07:03.318
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5daad59a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5256fbc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-06-27 20:07:52.214
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-07-03 12:27:24.494 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-07-03 12:27:48.022
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-07-03 12:27:48.022
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@56f2c9e8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@457692cb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-07-03 12:28:12.246
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-07-11 10:46:04.622 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-07-11 10:46:27.447
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-07-11 10:46:27.447
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11295cb1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5daad59a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-07-11 10:46:57.575
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-07-13 15:01:32.596 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-07-13 15:02:02.794
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-07-13 15:02:02.796
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5a205ee5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7fb44737,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-07-13 15:02:37.180
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-08-24 14:29:33.726 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-08-24 14:29:58.787
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-08-24 14:29:58.787
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@350342e0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d297d4d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-08-24 14:30:54.208
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-08-28 14:47:19.446 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-08-28 14:47:45.383
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-08-28 14:47:45.383
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8ef1d58,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2619cb76,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-08-28 14:48:12.531
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-08-30 13:19:17.807 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-08-30 13:20:01.592
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-08-30 13:20:01.592
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58f50dd0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3620eab,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-08-30 13:20:55.245
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.touchpoint.natives 2 0 2021-08-30 13:25:37.031
!MESSAGE Could not remove temporary backup directory (it is safe to manually delete it and its contents): C:\Users\Ayush\AppData\Local\Temp\C__Users_Ayush_eclipse_java-2021-03_eclipse_2f72c1ce91e0_c0a80101e5c6
!SESSION 2021-08-30 13:26:20.642 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data file:/E:/AYUSH/Programming/J2/ -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-08-30 13:26:57.845
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-08-30 13:26:57.845
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7698a3d9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b62f1ba,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-08-30 13:27:12.561
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-03 09:50:38.359 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-03 09:51:10.036
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-03 09:51:10.037
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@131d977f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@616f81b5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     !SESSION 2021-09-03 09:55:31.354 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2021-09-03 09:55:44.725
!MESSAGE Could not read metadata for 'E:\AYUSH\Programming\J2\.metadata\.plugins\org.eclipse.core.resources\.root\.indexes\properties.index'. Unexpected version: 0.

!ENTRY org.eclipse.jface 2 0 2021-09-03 09:56:01.831
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-03 09:56:01.831
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@152891f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1d2c253,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-03 09:56:29.962
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.buildship.core 2 0 2021-09-03 09:56:30.662
!MESSAGE Could not load Gradle version information
!STACK 0
com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_ARRAY but was STRING at line 1 column 1 path $
	at com.google.gson.Gson.fromJson(Gson.java:944)
	at com.google.gson.Gson.fromJson(Gson.java:897)
	at com.google.gson.Gson.fromJson(Gson.java:846)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersions.create(PublishedGradleVersions.java:206)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersions.tryToReadUpToDateVersionsFile(PublishedGradleVersions.java:124)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersions.create(PublishedGradleVersions.java:114)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersionsWrapper$LoadVersionsJob.run(PublishedGradleVersionsWrapper.java:60)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.IllegalStateException: Expected BEGIN_ARRAY but was STRING at line 1 column 1 path $
	at com.google.gson.stream.JsonReader.beginArray(JsonReader.java:351)
	at com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter.read(CollectionTypeAdapterFactory.java:80)
	at com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter.read(CollectionTypeAdapterFactory.java:61)
	at com.google.gson.Gson.fromJson(Gson.java:932)
	... 7 more

!ENTRY org.eclipse.oomph.setup.core 2 0 2021-09-03 09:56:51.646
!MESSAGE The Eclipse Git-hosted URI 'http://git.eclipse.org/c/oomph/org.eclipse.oomph.git/plain/setups/org.eclipse.setup' is blocked for direct access.
Please open a Bugzilla to add it to an official Oomph catalog.
For initial testing, use the file system local version of the resource.
Alternatively, run the setup archiver application as follows:
  C:\Users\Ayush\eclipse\java-2021-03\eclipse\eclipsec.exe -application org.eclipse.oomph.setup.core.SetupArchiver -consoleLog -noSplash -uris http://git.eclipse.org/c/oomph/org.eclipse.oomph.git/plain/setups/org.eclipse.setup
!SESSION 2021-09-03 09:57:30.797 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data file:/E:/AYUSH/Programming/J2/ -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-03 09:57:42.685
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-03 09:57:42.685
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5fe3b058,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a661215,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.buildship.core 2 0 2021-09-03 09:57:58.286
!MESSAGE Could not load Gradle version information
!STACK 0
com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_ARRAY but was STRING at line 1 column 1 path $
	at com.google.gson.Gson.fromJson(Gson.java:944)
	at com.google.gson.Gson.fromJson(Gson.java:897)
	at com.google.gson.Gson.fromJson(Gson.java:846)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersions.create(PublishedGradleVersions.java:206)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersions.tryToReadUpToDateVersionsFile(PublishedGradleVersions.java:124)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersions.create(PublishedGradleVersions.java:114)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersionsWrapper$LoadVersionsJob.run(PublishedGradleVersionsWrapper.java:60)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.IllegalStateException: Expected BEGIN_ARRAY but was STRING at line 1 column 1 path $
	at com.google.gson.stream.JsonReader.beginArray(JsonReader.java:351)
	at com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter.read(CollectionTypeAdapterFactory.java:80)
	at com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter.read(CollectionTypeAdapterFactory.java:61)
	at com.google.gson.Gson.fromJson(Gson.java:932)
	... 7 more

!ENTRY org.eclipse.egit.ui 2 0 2021-09-03 09:57:58.520
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.oomph.setup.core 2 0 2021-09-03 09:58:18.233
!MESSAGE The Eclipse Git-hosted URI 'http://git.eclipse.org/c/oomph/org.eclipse.oomph.git/plain/setups/org.eclipse.setup' is blocked for direct access.
Please open a Bugzilla to add it to an official Oomph catalog.
For initial testing, use the file system local version of the resource.
Alternatively, run the setup archiver application as follows:
  C:\Users\Ayush\eclipse\java-2021-03\eclipse\eclipsec.exe -application org.eclipse.oomph.setup.core.SetupArchiver -consoleLog -noSplash -uris http://git.eclipse.org/c/oomph/org.eclipse.oomph.git/plain/setups/org.eclipse.setup
!SESSION 2021-09-03 10:07:26.691 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-03 10:07:51.356
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-03 10:07:51.356
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@79617c3d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49cceb19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-03 10:08:29.140
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.buildship.core 2 0 2021-09-03 10:08:30.142
!MESSAGE Could not load Gradle version information
!STACK 0
com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_ARRAY but was STRING at line 1 column 1 path $
	at com.google.gson.Gson.fromJson(Gson.java:944)
	at com.google.gson.Gson.fromJson(Gson.java:897)
	at com.google.gson.Gson.fromJson(Gson.java:846)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersions.create(PublishedGradleVersions.java:206)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersions.tryToReadUpToDateVersionsFile(PublishedGradleVersions.java:124)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersions.create(PublishedGradleVersions.java:114)
	at org.eclipse.buildship.core.internal.util.gradle.PublishedGradleVersionsWrapper$LoadVersionsJob.run(PublishedGradleVersionsWrapper.java:60)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.IllegalStateException: Expected BEGIN_ARRAY but was STRING at line 1 column 1 path $
	at com.google.gson.stream.JsonReader.beginArray(JsonReader.java:351)
	at com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter.read(CollectionTypeAdapterFactory.java:80)
	at com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter.read(CollectionTypeAdapterFactory.java:61)
	at com.google.gson.Gson.fromJson(Gson.java:932)
	... 7 more
!SESSION 2021-09-08 09:48:10.227 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-08 09:48:38.819
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-08 09:48:38.819
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49cceb19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@197d5a87,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-08 09:49:08.699
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-08 11:23:37.740 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-08 11:24:02.821
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-08 11:24:02.821
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4f552aa2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c8fe8ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-08 11:24:21.058
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-14 15:39:38.877 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-14 15:40:11.286
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-14 15:40:11.286
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@46994f26,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1bb172dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-14 15:40:39.146
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.touchpoint.natives 2 0 2021-09-14 15:47:11.092
!MESSAGE Could not remove temporary backup directory (it is safe to manually delete it and its contents): C:\Users\Ayush\AppData\Local\Temp\C__Users_Ayush_eclipse_java-2021-03_eclipse_2f7c79edbb60_c0a80069dcfb
!SESSION 2021-09-14 15:49:28.977 -----------------------------------------------
eclipse.buildId=4.20.0.I20210611-1600
java.version=11.0.9
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data file:/E:/AYUSH/Programming/J2/ -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-14 15:55:22.831
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-14 15:55:22.832
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7698a3d9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b62f1ba,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-14 15:55:49.851
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 4 2021-09-14 16:00:28.227
!MESSAGE Unable to create part
!STACK 1
org.eclipse.ui.PartInitException: Cannot determine URI for '/dsaSelfPace/src/recursion/RecursionProblems.java'.
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3203)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3214)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:344)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1380)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1330)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1960)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:335)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1434)
Caused by: org.eclipse.core.runtime.CoreException: Cannot determine URI for '/dsaSelfPace/src/recursion/RecursionProblems.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4182)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2544)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2517)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1410)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3172)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3189)
	... 77 more
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2021-09-14 16:00:28.241
!MESSAGE Cannot determine URI for '/dsaSelfPace/src/recursion/RecursionProblems.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/dsaSelfPace/src/recursion/RecursionProblems.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4182)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2544)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2517)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1410)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3172)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3189)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3214)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:344)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1380)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1330)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1960)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:335)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1434)
!SUBENTRY 2 org.eclipse.core.filebuffers 4 0 2021-09-14 16:00:28.259
!MESSAGE Cannot determine URI for '/dsaSelfPace/src/recursion/RecursionProblems.java'.

!ENTRY org.eclipse.ui 4 4 2021-09-14 16:00:32.628
!MESSAGE Unable to create part
!STACK 1
org.eclipse.ui.PartInitException: Cannot determine URI for '/dsaSelfPace/src/binaryTree/BinaryTreeProblems.java'.
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3203)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3214)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:344)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1380)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1330)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1960)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:335)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1434)
Caused by: org.eclipse.core.runtime.CoreException: Cannot determine URI for '/dsaSelfPace/src/binaryTree/BinaryTreeProblems.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4182)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2544)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2517)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1410)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3172)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3189)
	... 77 more
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2021-09-14 16:00:32.637
!MESSAGE Cannot determine URI for '/dsaSelfPace/src/binaryTree/BinaryTreeProblems.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/dsaSelfPace/src/binaryTree/BinaryTreeProblems.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4182)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2544)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2517)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1410)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3172)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3189)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3214)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:344)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1380)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1330)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1960)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:335)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1434)
!SUBENTRY 2 org.eclipse.core.filebuffers 4 0 2021-09-14 16:00:32.638
!MESSAGE Cannot determine URI for '/dsaSelfPace/src/binaryTree/BinaryTreeProblems.java'.

!ENTRY org.eclipse.ui 4 4 2021-09-14 16:00:35.801
!MESSAGE Unable to create part
!STACK 1
org.eclipse.ui.PartInitException: Cannot determine URI for '/dsaSelfPace/src/strings/Strings.java'.
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3203)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3214)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:344)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3243)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1881)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:330)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1434)
Caused by: org.eclipse.core.runtime.CoreException: Cannot determine URI for '/dsaSelfPace/src/strings/Strings.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4182)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2544)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2517)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1410)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3172)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3189)
	... 83 more
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2021-09-14 16:00:35.803
!MESSAGE Cannot determine URI for '/dsaSelfPace/src/strings/Strings.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/dsaSelfPace/src/strings/Strings.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:239)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:115)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:563)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:1018)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:481)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1284)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4182)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:262)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1479)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2544)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2517)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1410)
	at org.eclipse.ui.texteditor.AbstractTextEditor.lambda$1(AbstractTextEditor.java:3172)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3189)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3214)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:353)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:344)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3243)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1881)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:330)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1434)
!SUBENTRY 2 org.eclipse.core.filebuffers 4 0 2021-09-14 16:00:35.804
!MESSAGE Cannot determine URI for '/dsaSelfPace/src/strings/Strings.java'.
!SESSION 2021-09-20 11:52:14.188 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-20 11:54:26.310
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-20 11:54:26.310
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@736788b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@38968752,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-20 11:55:32.898
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\AYUSH'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-21 16:15:40.098 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-21 16:16:21.793
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-21 16:16:21.793
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5e2975ca,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@38cf4497,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-21 16:16:44.204
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\AYUSH'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-23 11:55:53.169 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-09-23 11:56:00.550
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2021-09-23 11:56:09.904
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-23 11:56:09.904
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@733fa95c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3b2c8bda,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-23 11:56:26.363
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\AYUSH'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-23 12:29:32.579 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data file:/E:/AYUSH/Programming/J2/ -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-23 12:29:42.499
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-23 12:29:42.499
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@212e39ee,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@638d2ce3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-23 12:29:53.270
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\AYUSH'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-28 10:46:51.062 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-28 10:47:12.998
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-28 10:47:12.998
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4f552aa2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c8fe8ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-28 10:47:31.043
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\AYUSH'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-28 14:49:43.167 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-28 14:50:02.416
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-28 14:50:02.416
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4f552aa2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c8fe8ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-28 14:50:14.156
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\AYUSH'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-09-28 15:20:00.787 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=16.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data file:/E:/AYUSH/Programming/J2/ -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-09-28 15:20:12.157
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-09-28 15:20:12.157
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@638d2ce3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@79617c3d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-09-28 15:20:22.693
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\AYUSH'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-09 15:40:10.584 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-10-09 15:40:30.544
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.core.resources 4 567 2021-10-09 15:40:30.655
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2021-10-09 15:40:30.655
!MESSAGE Could not read metadata for '.org.eclipse.egit.core.cmp'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/.org.eclipse.egit.core.cmp)[567]: java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.lambda$2(BundleContextImpl.java:808)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:802)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:759)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1019)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:365)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:404)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:388)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:463)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2021-10-09 15:40:30.655
!MESSAGE The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.lambda$2(BundleContextImpl.java:808)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:802)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:759)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1019)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:365)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:404)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:388)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:463)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jface 2 0 2021-10-09 15:40:32.484
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-09 15:40:32.484
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@457692cb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@350342e0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-09 15:40:36.897
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-10-09 15:40:37.471
!MESSAGE Exception while reading last build state for: P/Challenges
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project Challenges
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4125)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-11.0.9\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-11.0.9\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2021-10-09 15:40:37.471
!MESSAGE Error reading last build state for project Challenges
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-11.0.9\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-11.0.9\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2021-10-09 15:40:37.472
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-11.0.9\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-11.0.9\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-10-09 15:40:37.669
!MESSAGE Exception while reading last build state for: P/DSA
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project DSA
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4125)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-11.0.9\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-11.0.9\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2021-10-09 15:40:37.670
!MESSAGE Error reading last build state for project DSA
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-11.0.9\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-11.0.9\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2021-10-09 15:40:37.670
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-11.0.9\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-11.0.9\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-10-09 17:00:27.924 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-09 17:00:32.140
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-09 17:00:32.140
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@430d3021,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58f290bc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-09 17:00:36.445
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-12 11:38:47.333 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-12 11:38:51.751
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-12 11:38:51.751
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8debe42,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70c31b17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-12 11:38:55.920
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-18 17:49:14.663 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-18 17:49:18.898
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-18 17:49:18.898
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8debe42,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70c31b17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-18 17:49:23.044
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-20 17:09:10.428 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-20 17:09:14.702
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-20 17:09:14.702
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-20 17:09:18.856
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-21 16:58:43.533 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-21 16:58:47.779
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-21 16:58:47.779
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-21 16:58:51.787
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-21 18:55:06.847 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-21 18:55:11.207
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-21 18:55:11.207
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-21 18:55:15.490
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-22 10:53:04.336 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-22 10:53:08.522
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-22 10:53:08.522
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-22 10:53:12.608
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-22 13:09:50.229 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-22 13:09:54.840
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-22 13:09:54.841
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-22 13:09:59.324
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-22 18:13:50.620 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-22 18:13:55.128
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-22 18:13:55.128
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-22 18:13:59.240
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-23 12:11:38.614 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-23 12:11:42.886
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-23 12:11:42.886
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-23 12:11:48.573
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-26 21:55:07.729 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-26 21:55:11.776
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-26 21:55:11.776
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-26 21:55:15.657
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-27 11:55:33.274 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-27 11:55:37.938
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-27 11:55:37.938
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-27 11:55:42.205
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-27 15:09:00.476 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-27 15:09:04.211
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-27 15:09:04.212
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@50672905,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-27 15:09:07.644
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-27 22:13:33.418 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-27 22:13:37.824
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-27 22:13:37.824
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-27 22:13:41.578
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-28 16:41:28.286 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-28 16:41:33.021
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-28 16:41:33.021
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-28 16:41:37.104
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-29 15:24:44.758 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-29 15:24:49.360
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-29 15:24:49.360
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8debe42,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70c31b17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-29 15:24:53.451
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-30 13:10:19.110 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-30 13:10:23.851
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-30 13:10:23.851
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-30 13:10:27.752
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-10-31 14:33:20.917 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-10-31 14:33:28.315
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-10-31 14:33:28.315
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-10-31 14:33:35.638
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-02 11:23:09.919 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-02 11:23:18.278
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-02 11:23:18.278
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-02 11:23:26.499
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-03 13:48:17.597 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-03 13:48:21.679
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-03 13:48:21.679
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-03 13:48:25.672
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-05 12:46:07.860 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-05 12:46:13.332
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-05 12:46:13.332
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-05 12:46:20.352
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-05 15:19:50.921 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-05 15:19:57.156
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-05 15:19:57.156
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-05 15:20:03.354
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-08 11:04:36.558 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-08 11:04:41.023
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-08 11:04:41.024
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-08 11:04:45.650
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-09 17:18:45.511 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-09 17:18:49.648
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-09 17:18:49.648
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-09 17:18:53.630
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-11-09 17:26:59.351
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.Scanner;

public class BinaryTree<E> {
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		Node root = createTree();
		System.out.println("Inorder");
		inOrder(root);
		System.out.println("Preorder");
		preOrder(root);
		System.out.println("Postorder");
		postOrder(root);
		System.out.println("Height");
		System.out.println(height(root));
	}
	
	public static List<ArrayLis<Integer>> levelOrderTraversal()
	
	static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
		
	static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// Height/Depth of a Binary Tree.
	static int height(Node root) {
		if(root == null) return 0;
	
		int leftHeight = height(root.left);
		int rightHeight = height(root.right);
		
		return 1 + Math.max(leftHeight, rightHeight);
		
	}	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}














----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-09 17:26:59.354
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-09 17:26:59.354
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-09 17:27:04.373
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.Scanner;

public class BinaryTree<E> {
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		Node root = createTree();
		System.out.println("Inorder");
		inOrder(root);
		System.out.println("Preorder");
		preOrder(root);
		System.out.println("Postorder");
		postOrder(root);
		System.out.println("Height");
		System.out.println(height(root));
	}
	
	public static List<ArrayLis<Integer>> levelOrderTraversal(Node root)
	
	static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
		
	static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// Height/Depth of a Binary Tree.
	static int height(Node root) {
		if(root == null) return 0;
	
		int leftHeight = height(root.left);
		int rightHeight = height(root.right);
		
		return 1 + Math.max(leftHeight, rightHeight);
		
	}	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}














----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-09 17:27:04.374
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-09 17:27:04.374
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2021-11-09 22:41:00.669 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-09 22:41:04.642
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-09 22:41:04.642
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@50672905,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-09 22:41:08.308
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 2 10035 2021-11-09 23:23:25.160
!MESSAGE The workspace will exit with unsaved changes in this session.
!SESSION 2021-11-10 10:11:20.222 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-11-10 10:11:22.212
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2021-11-10 10:11:24.447
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-10 10:11:24.447
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e4f2300,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@e706aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-10 10:11:28.450
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-10 14:45:16.810 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-10 14:45:19.900
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-10 14:45:19.900
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-10 14:45:22.677
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-10 22:28:58.054 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-10 22:29:02.231
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-10 22:29:02.232
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-10 22:29:06.371
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-11 11:18:00.374 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-11 11:18:05.042
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-11 11:18:05.042
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8debe42,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70c31b17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-11 11:18:09.371
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-11 18:23:40.442 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-11 18:23:44.257
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-11 18:23:44.257
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-11 18:23:48.472
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-11 22:59:04.420 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-11 22:59:08.260
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-11 22:59:08.260
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-11 22:59:12.025
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-12 13:19:12.983 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-12 13:19:17.057
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-12 13:19:17.057
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3129299f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f73f0c7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-12 13:19:21.162
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-11-12 13:21:52.471
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				  /	  \
		 * 				 2	   3
		 * 				/ \		
		 * 			   4   5
		 * 				  / \
		 * 				 6   7
		 */
		
		Node root = new Node(1);
		root.left = new Node(2);
		root.left.left = new Node(4);
		
		root.right = new Node(3);
		
		root.left.right = new Node(5);
		
		root.left.right.left = new Node(6);
		root.left.right.right = new Node(7);
		
		
		System.out.println(iterativePostorderTraversal(root));
	}
	
	public static int heightOfABinaryTree(Node root)
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		
		return wrapList;
		
	}
	
	static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
		
	static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// Height/Depth of a Binary Tree.
	static int height(Node root) {
		if(root == null) return 0;
	
		int leftHeight = height(root.left);
		int rightHeight = height(root.right);
		
		return 1 + Math.max(leftHeight, rightHeight);
		
	}	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}














----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-12 13:21:52.473
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-12 13:21:52.473
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2021-11-13 10:37:45.263 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-13 10:37:49.137
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-13 10:37:49.137
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-13 10:37:53.176
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-23 14:31:00.400 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-23 14:31:04.470
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-23 14:31:04.470
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-23 14:31:08.627
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-23 16:36:42.285 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-23 16:36:45.811
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-23 16:36:45.811
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-23 16:36:49.384
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-23 22:17:49.790 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-23 22:17:54.042
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-23 22:17:54.042
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-23 22:17:57.669
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-11-23 22:26:42.222
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cp;

import java.util.*;

public class CP_BeautifulYear271A {

	public static void main(String[] args) {
		
		solution();
		
	}
	
	public static void solution() {
		
		Scanner sc = new Scanner(System.in);
		
		int year = sc.nextInt();
		sc.close();
		
		for(int i = year+1; i <= 9000; ++i) {
			boolean res = isUniqueDigits(year);
			if(res) System.out.println(i);
		}
		
	}
	
	public static boolean isUniqueDigits(int year) {
		
		Set<Integer> digit = new HashSet<Integer>();
		
		for(int i = 0; i < 4; ++i) {
			year%10
		}
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-23 22:26:42.227
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-23 22:26:42.229
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-23 22:26:42.244
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cp;

import java.util.*;

public class CP_BeautifulYear271A {

	public static void main(String[] args) {
		
		solution();
		
	}
	
	public static void solution() {
		
		Scanner sc = new Scanner(System.in);
		
		int year = sc.nextInt();
		sc.close();
		
		for(int i = year+1; i <= 9000; ++i) {
			boolean res = isUniqueDigits(year);
			if(res) System.out.println(i);
		}
		
	}
	
	public static boolean isUniqueDigits(int year) {
		
		Set<Integer> digit = new HashSet<Integer>();
		
		for(int i = 0; i < 4; ++i) {
			year%10
		}
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-11-23 22:26:42.246
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-11-23 22:26:42.247
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:21.960
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:22.319
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:22.513
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:22.704
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:23.901
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:24.209
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:24.447
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:24.655
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:24.866
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:25.117
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:25.504
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:25.752
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:26.008
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:26.330
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:26.607
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:26.886
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:27.166
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:27.416
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:27.674
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:28.043
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:28.445
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:178)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:158)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2021-11-23 22:38:31.706
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at java.base/java.io.FilterOutputStream.close(FilterOutputStream.java:182)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:162)
	at java.base/java.lang.Thread.run(Thread.java:833)
!SESSION 2021-11-24 11:42:00.132 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-24 11:42:04.055
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-24 11:42:04.055
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-24 11:42:07.833
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-24 16:02:14.441 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-24 16:02:18.020
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-24 16:02:18.020
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-24 16:02:23.068
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-24 17:50:43.702 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-24 17:50:49.422
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-24 17:50:49.422
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@50672905,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@430d3021,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-24 17:50:54.542
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-25 11:41:01.805 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-25 11:41:05.716
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-25 11:41:05.716
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@50672905,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-25 11:41:09.398
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 2 2 2021-11-25 13:20:35.726
!MESSAGE Save operation warnings.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2021-11-25 13:20:35.726
!MESSAGE The project description file (.project) for 'Tools' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SESSION 2021-11-25 15:40:52.795 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-25 15:40:56.619
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-25 15:40:56.619
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-25 15:41:00.238
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-25 19:59:17.371 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-25 19:59:20.744
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-25 19:59:20.745
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f73f0c7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4fdac2a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-25 19:59:24.003
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-25 21:39:24.199 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-25 21:39:30.175
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-25 21:39:30.175
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58f290bc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3220c28,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-25 21:39:33.818
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-26 11:30:15.580 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-26 11:30:19.710
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-26 11:30:19.710
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70c31b17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-26 11:30:25.481
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-26 12:46:39.186 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-26 12:46:42.410
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-26 12:46:42.410
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-26 12:46:46.779
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-27 11:45:20.083 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-27 11:45:22.216
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-27 11:45:22.216
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-27 11:45:28.047
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-27 21:51:48.018 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-27 21:51:53.812
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-27 21:51:53.812
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@50672905,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@430d3021,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-27 21:51:57.535
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-11-27 22:14:34.789
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 					/
		 * 				   69
		 */
		
		Node root1 = new Node(1);
		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left= new Node(69);
		root1.left.right.right.right= new Node(70);
		
		Node root2 = new Node(1);
		root2.left = new Node(2);
		root2.left.left = new Node(4);
		
		root2.right = new Node(3);
		
		root2.left.right = new Node(5);
		
		root2.left.right.left = new Node(6);
		root2.left.right.right = new Node(7);
		root2.left.right.right.left= new Node(69);
		
		
		//System.out.println(balancedBinaryTree(root));

		System.out.println(boundaryTraversal(root1));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void leftBoundary()
	
	public static ArrayList<Integer> boundaryTraversal(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<List<Integer>>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) isIdentical[0] = false;
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Copied
	public static boolean isSameTree2(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree2(root1.left, root2.left) && isSameTree2(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}














----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-27 22:14:34.790
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-27 22:14:34.791
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-27 22:14:37.808
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 					/
		 * 				   69
		 */
		
		Node root1 = new Node(1);
		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left= new Node(69);
		root1.left.right.right.right= new Node(70);
		
		Node root2 = new Node(1);
		root2.left = new Node(2);
		root2.left.left = new Node(4);
		
		root2.right = new Node(3);
		
		root2.left.right = new Node(5);
		
		root2.left.right.left = new Node(6);
		root2.left.right.right = new Node(7);
		root2.left.right.right.left= new Node(69);
		
		
		//System.out.println(balancedBinaryTree(root));

		System.out.println(boundaryTraversal(root1));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void leftBoundary(Node root)
	
	public static ArrayList<Integer> boundaryTraversal(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<List<Integer>>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) isIdentical[0] = false;
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Copied
	public static boolean isSameTree2(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree2(root1.left, root2.left) && isSameTree2(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}














----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-27 22:14:37.810
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-27 22:14:37.810
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-27 22:14:41.326
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 					/
		 * 				   69
		 */
		
		Node root1 = new Node(1);
		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left= new Node(69);
		root1.left.right.right.right= new Node(70);
		
		Node root2 = new Node(1);
		root2.left = new Node(2);
		root2.left.left = new Node(4);
		
		root2.right = new Node(3);
		
		root2.left.right = new Node(5);
		
		root2.left.right.left = new Node(6);
		root2.left.right.right = new Node(7);
		root2.left.right.right.left= new Node(69);
		
		
		//System.out.println(balancedBinaryTree(root));

		System.out.println(boundaryTraversal(root1));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void leftBoundary(Node root, ArrayLis)
	
	public static ArrayList<Integer> boundaryTraversal(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<List<Integer>>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) isIdentical[0] = false;
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Copied
	public static boolean isSameTree2(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree2(root1.left, root2.left) && isSameTree2(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}














----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-27 22:14:41.327
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-27 22:14:41.328
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-27 22:14:42.841
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 					/
		 * 				   69
		 */
		
		Node root1 = new Node(1);
		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left= new Node(69);
		root1.left.right.right.right= new Node(70);
		
		Node root2 = new Node(1);
		root2.left = new Node(2);
		root2.left.left = new Node(4);
		
		root2.right = new Node(3);
		
		root2.left.right = new Node(5);
		
		root2.left.right.left = new Node(6);
		root2.left.right.right = new Node(7);
		root2.left.right.right.left= new Node(69);
		
		
		//System.out.println(balancedBinaryTree(root));

		System.out.println(boundaryTraversal(root1));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void leftBoundary(Node root, ArrayList<I>)
	
	public static ArrayList<Integer> boundaryTraversal(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<List<Integer>>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) isIdentical[0] = false;
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Copied
	public static boolean isSameTree2(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree2(root1.left, root2.left) && isSameTree2(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}














----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-27 22:14:42.842
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-27 22:14:42.843
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-27 22:14:44.357
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 					/
		 * 				   69
		 */
		
		Node root1 = new Node(1);
		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left= new Node(69);
		root1.left.right.right.right= new Node(70);
		
		Node root2 = new Node(1);
		root2.left = new Node(2);
		root2.left.left = new Node(4);
		
		root2.right = new Node(3);
		
		root2.left.right = new Node(5);
		
		root2.left.right.left = new Node(6);
		root2.left.right.right = new Node(7);
		root2.left.right.right.left= new Node(69);
		
		
		//System.out.println(balancedBinaryTree(root));

		System.out.println(boundaryTraversal(root1));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void leftBoundary(Node root, ArrayList<Inte>)
	
	public static ArrayList<Integer> boundaryTraversal(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<List<Integer>>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) isIdentical[0] = false;
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Copied
	public static boolean isSameTree2(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree2(root1.left, root2.left) && isSameTree2(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}














----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-27 22:14:44.358
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-27 22:14:44.358
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-27 22:14:45.376
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 					/
		 * 				   69
		 */
		
		Node root1 = new Node(1);
		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left= new Node(69);
		root1.left.right.right.right= new Node(70);
		
		Node root2 = new Node(1);
		root2.left = new Node(2);
		root2.left.left = new Node(4);
		
		root2.right = new Node(3);
		
		root2.left.right = new Node(5);
		
		root2.left.right.left = new Node(6);
		root2.left.right.right = new Node(7);
		root2.left.right.right.left= new Node(69);
		
		
		//System.out.println(balancedBinaryTree(root));

		System.out.println(boundaryTraversal(root1));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void leftBoundary(Node root, ArrayList<Integer>)
	
	public static ArrayList<Integer> boundaryTraversal(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<List<Integer>>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) isIdentical[0] = false;
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Copied
	public static boolean isSameTree2(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree2(root1.left, root2.left) && isSameTree2(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}














----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-27 22:14:45.378
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-27 22:14:45.379
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-11-27 22:14:49.906
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 					/
		 * 				   69
		 */
		
		Node root1 = new Node(1);
		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left= new Node(69);
		root1.left.right.right.right= new Node(70);
		
		Node root2 = new Node(1);
		root2.left = new Node(2);
		root2.left.left = new Node(4);
		
		root2.right = new Node(3);
		
		root2.left.right = new Node(5);
		
		root2.left.right.left = new Node(6);
		root2.left.right.right = new Node(7);
		root2.left.right.right.left= new Node(69);
		
		
		//System.out.println(balancedBinaryTree(root));

		System.out.println(boundaryTraversal(root1));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void leftBoundary(Node root, ArrayList<Integer>) {
	
	public static ArrayList<Integer> boundaryTraversal(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<List<Integer>>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) isIdentical[0] = false;
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Copied
	public static boolean isSameTree2(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree2(root1.left, root2.left) && isSameTree2(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}














----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-11-27 22:14:49.907
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-11-27 22:14:49.907
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2021-11-28 12:47:12.347 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-28 12:47:16.086
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-28 12:47:16.086
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-28 12:47:20.225
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 2 2 2021-11-28 14:06:39.620
!MESSAGE Save operation warnings.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2021-11-28 14:06:39.621
!MESSAGE The project description file (.project) for 'Tools' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SESSION 2021-11-29 11:05:18.563 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-29 11:05:22.666
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-29 11:05:22.666
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-29 11:05:26.896
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-29 22:32:46.294 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-29 22:32:50.325
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-29 22:32:50.325
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-29 22:32:54.154
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-30 11:56:14.926 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-30 11:56:18.757
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-30 11:56:18.757
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-30 11:56:22.386
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-30 18:37:34.766 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-30 18:37:38.280
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-30 18:37:38.280
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-30 18:37:41.701
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-11-30 22:33:55.640 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-30 22:33:59.578
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-30 22:33:59.578
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-11-30 22:34:03.467
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-01 10:46:52.299 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-01 10:46:58.086
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-01 10:46:58.086
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-01 10:47:02.259
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-01 12:19:55.198 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-01 12:19:58.618
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-01 12:19:58.618
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-01 12:20:02.248
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-01 21:58:25.105 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-01 21:58:31.983
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-01 21:58:31.983
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-01 21:58:37.177
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-02 10:28:14.075 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 10:28:18.013
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 10:28:18.014
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-02 10:28:21.884
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-02 14:56:28.640 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2021-12-02 14:56:30.476
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2021-12-02 14:56:30.476
!MESSAGE Could not read metadata for 'Tools'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Tools)[567]: java.lang.Exception: The project description file (.project) for 'Tools' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.lambda$2(BundleContextImpl.java:808)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:802)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:759)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1019)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:365)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:404)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:388)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:463)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2021-12-02 14:56:30.476
!MESSAGE The project description file (.project) for 'Tools' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Tools' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.lambda$2(BundleContextImpl.java:808)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:802)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:759)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1019)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:365)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:404)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:388)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:463)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jface 2 0 2021-12-02 14:56:32.566
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 14:56:32.566
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3e01796a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@62ab5e63,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-02 14:56:36.629
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-02 22:49:39.520 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 22:49:44.832
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 22:49:44.832
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@50672905,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-02 22:49:49.803
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-03 15:25:11.409 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-03 15:25:15.428
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-03 15:25:15.428
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-03 15:25:19.579
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-03 17:54:09.847 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-03 17:54:17.519
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-03 17:54:17.519
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@50672905,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@430d3021,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-03 17:54:24.652
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-03 22:00:25.538 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-03 22:00:29.489
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-03 22:00:29.489
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-03 22:00:34.859
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-03 22:43:31.815 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-03 22:43:35.579
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-03 22:43:35.579
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-03 22:43:39.413
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-04 12:44:19.359 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-04 12:44:23.990
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-04 12:44:23.990
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-04 12:44:29.375
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-04 19:48:19.896 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-04 19:48:25.373
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-04 19:48:25.373
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-04 19:48:29.816
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-05 10:13:04.190 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-05 10:13:07.960
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-05 10:13:07.960
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-05 10:13:11.062
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-05 14:20:52.927 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-05 14:20:56.266
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-05 14:20:56.266
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-05 14:21:00.288
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-06 12:20:59.595 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-06 12:21:06.618
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-06 12:21:06.618
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-06 12:21:10.755
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-06 14:52:37.611 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-06 14:52:42.003
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-06 14:52:42.003
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-06 14:52:46.929
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-12-06 15:09:32.169
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 				   / \
		 * 				  69  70
		 * 						\
		 * 						700
		 */
		
		Node root1 = new Node(1);

		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left = new Node(69);
		root1.left.right.right.right = new Node(70);
		root1.left.right.right.right.right = new Node(700);
		
		/**
		 * 					10
		 * 				  /    \
		 * 				 5	   20
		 * 				/ \    / \
		 * 			   3   8  18  25 
		 * 
		 * 
		 */
		
		Node root2 = new Node(10);
		
		root2.left = new Node(5);
		root2.left.right = new Node(8);
		root2.left.right.left = new Node(7);
		root2.left.left = new Node(3);
		
		root2.right = new Node(20);
		root2.right.left = new Node(18);
		root2.right.right = new Node(25);
		
		
		//System.out.println(balancedBinaryTree(root));

		//System.out.println(boundaryTraversal(root2));
		
		//System.out.println(topViewOfBT(root2));
		
		System.out.println(minimumTimeToBurnBT(root1, 4));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	public static int minimumTimeToBurnBT(Node root, int start) {
		HashMap<Node, Node> parent = new HashMap<>();
		Node target = markParent(root, parent);
		
		return burnTree(target, parent);
	}
	
	public static int burnTree()
	
	public static Node markParent(Node root, HashMap<Node, Node> parent) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> distanceK(Node root, Node target, int k ) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		// Child, Parent
		Map<Node, Node> parentTrack = new HashMap<>();
		markParents(root, parentTrack, target);
		
		Map<Node, Boolean> visited = new HashMap<>();
		Queue<Node> q = new LinkedList<>();
		
		q.offer(target);
		visited.put(target, true);
		int curLevel = 0;
		
		while(!q.isEmpty()) {
			int size = q.size();
			
			if(curLevel++ == k) break;
			
			for(int i = 0; i < size; ++i) {
				Node cur = q.poll();
				
				if(cur.left != null && visited.get(cur.left) == null) {
					q.offer(cur.left);
					visited.put(cur.left, true);
				}
				if(cur.right != null && visited.get(cur.right) == null) {
					q.offer(cur.right);
					visited.put(cur.right, true);
				}
				if(parentTrack.get(cur) != null && visited.get(parentTrack.get(cur)) == null) {
					q.offer(parentTrack.get(cur));
					visited.put(parentTrack.get(cur), true);
				}
			}
		}
		
		for(Node i : q) {
			res.add(i.data);
		}
		
		return res;
	}
	
	public static void markParents(Node root, Map<Node, Node> parentTrack, Node target) {
		Queue<Node> q = new LinkedList<>();
		q.offer(root);
		
		while(!q.isEmpty()) {
			Node cur = q.poll();
			
			if(cur.left != null) {
				parentTrack.put(cur.left, cur);
				q.offer(cur.left);
			}
			
			if(cur.right != null) {
				parentTrack.put(cur.right, cur);
				q.offer(cur.right);
			}
		}
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void childrenSumProperty(Node root) {
	// Feeling excited with other 69 PBC because I coded this on my own.
		if(root == null) return;
		
		int rootData = root.data;
		int leftChildData = 0;
		if(root.left != null) leftChildData = root.left.data;
		int rightChildData = 0;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		} else if(leftChildData + rightChildData < rootData) {
			if(root.left != null) root.left.data = root.data;
			if(root.right != null) root.right.data = root.data;
		}
		
		childrenSumProperty(root.left);
		childrenSumProperty(root.right);
		
		if(root.left != null) leftChildData = root.left.data;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		}
	}
	
	public static void maxWidthOfBT(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// brute force approach.
	
//	public static int lowestCommonAncestor(Node root, Node p, Node q) {
//		
//		Set<Integer> pPath = new LinkedHashSet<Integer>();
//		Set<Integer> qPath = new HashSet<Integer>();
//		getPath(root, p.data, pPath);
//		getPath(root, q.data, qPath);
//		
//		System.out.println(pPath.toString());
//		
//		int res = 0;
//		
//		for(Integer i : pPath) {
//			if(qPath.contains(i)) res = i;
//			else break;
//		}
//		
//		return res;
//	}
//	
//	public static boolean getPath(Node root, int n, Set<Integer> res) {
//		if(root == null) return false;
//		
//		res.add(root.data);
//		if(root.data == n) return true;
//		
//		if(getPath(root.left, n, res) || getPath(root.right, n, res)) {
//			return true;
//		}
//		
//		res.remove(root.data);		// Removing last element.
//		return false;
//	}
	
	public static Node lowestCommonAncestor(Node root, Node p, Node q) {
		if(root == null || root == p || root == q) return root;
		
		Node left = lowestCommonAncestor(root.left, p, q);
		Node right = lowestCommonAncestor(root.right, p, q);
		
		if(left == null) return right;
		else if(right == null) return left;
		else return root;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// 1 extra parameter.
	
//	public static LinkedList<Integer> rootToNodePath(Node root, int b) {
//		LinkedList<Integer> res = new LinkedList<>();
//		boolean isNodeFounded[] = {false};
//		solve(root, b, res, isNodeFounded);
//		return res;
//		
//	}
//	
//	public static void solve(Node root, int b, LinkedList<Integer> res, boolean isNodeFounded[]) {
//		if(root == null) return;
//		
//		solve(root.left, b, res, isNodeFounded);
//		if(!isNodeFounded[0]) solve(root.right, b, res, isNodeFounded);
//		if(root.data == b || isNodeFounded[0]) {
//			res.add(0, root.data);
//			isNodeFounded[0] = true;
//		}
//	}
	
	public static ArrayList<Integer> rootToNodePath(Node root, int b) {
		ArrayList<Integer> res = new ArrayList<>();
		solve(root, b, res);
		return res;
	}
	
	public static boolean solve(Node root, int b, ArrayList<Integer> res) {
		if(root == null) return false;
		
		res.add(root.data);
		if(root.data == b) return true;
		
		if(solve(root.left, b, res) || solve(root.right, b, res)) {
			return true;
		}
		
		res.remove(res.size() - 1);		// Removing last element.
		return false;
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	public static boolean symmetricBT(Node root) {
		if(root == null) return true;
		
		return isSymmetric(root.left, root.right);
	}
	
	public static boolean isSymmetric(Node root1, Node root2) {
		if(root1 == null || root2 == null) return root1==root2;
		
		return root1.data == root2.data 
				&& isSymmetric(root1.left, root2.right) 
				&& isSymmetric(root1.right, root2.left);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> rightViewOfBT(Node root) {
		List<Integer> res = new ArrayList<Integer>();
		getRightView(root, res, 0);
		return res;
	}
	
	public static void getRightView(Node root, List<Integer> res, int level) {
		if(root == null) return;
		
		if(level == res.size()) res.add(root.data);
		getRightView(root.right, res, level+1);
		getRightView(root.left, res, level+1);
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	
	// Class required for Bottom view and Top view.
	static class Pair {
		Node root;
		int col;
		public Pair(Node _root, int _col) {
			root = _root;
			col = _col;		// Vertical
		}
	}
	
	public static ArrayList<Integer> bottonViewOfBT(Node root) {
		ArrayList<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.put(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		
		return res;
	}
	
	public static List<Integer> topViewOfBT(Node root) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.putIfAbsent(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	// Class required for Vertical Traversal.
	static class Tuple {
		Node root;
		int row;		// Level
		int col;		// Vertical
		public Tuple(Node _root, int _row, int _col) {
			root = _root;
			row = _row;
			col = _col;
		}
	}
	
	public static List<List<Integer>> verticalTraversal(Node root) {
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		// Vertical, Level
		TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();
		Queue<Tuple> q = new LinkedList<>();
		q.offer(new Tuple(root, 0, 0));
		
		while(!q.isEmpty()) {
			Tuple t = q.poll();
			Node n = t.root;
			int x = t.row;
			int y = t.col;
			
			map.putIfAbsent(y, new TreeMap<>());	// Adding Vertical if absent.
			map.get(y).putIfAbsent(x, new PriorityQueue<>());	// Adding Level if absent.
			
			map.get(y).get(x).offer(n.data);
			
			if(n.left != null) q.offer(new Tuple(n.left, x+1, y-1));
			if(n.right != null) q.offer(new Tuple(n.right, x+1, y+1));
		}
		
		// Traversing over "map" to add node.data to List.
		for(TreeMap<Integer, PriorityQueue<Integer>> ys : map.values()) {
			List<Integer> v = new ArrayList<>();
			for(PriorityQueue<Integer> nodes : ys.values()) {
				while(!nodes.isEmpty()) {
					v.add(nodes.poll());
				}
			}
			res.add(v);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	// Below 4 method is for boundary traversal.
	
	// I coded this whole on my own. Best thing is I did it using recursion.
//	public static ArrayList<Integer> boundaryTraversal(Node root) {
//		ArrayList<Integer> res = new ArrayList<Integer>();
//		if(root == null) return res;
//		
//		res.add(root.data);
//		
//		leftBoundary(root.left, res);
//		leafBoundary(root, res);
//		
//		int size = res.size();
//		rightBoundary(root.right, res, size);
//		
//		return res;
//	}
//	
//	public static void leftBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.left == null) {
//			res.add(root.data);
//			leftBoundary(root.right, res);
//		} else {
//			res.add(root.data);
//			leftBoundary(root.left, res);
//		}
//	}
//	
//	public static void rightBoundary(Node root, ArrayList<Integer> res, int size) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.right == null) {
//			res.add(size, root.data);
//			rightBoundary(root.left, res, size);
//		} else {
//			res.add(size, root.data);
//			rightBoundary(root.right, res, size);
//		}
//	}
//
//	public static void leafBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		
//		if(root.left == null && root.right == null) {
//			res.add(root.data);
//			return;
//		}
//		
//		leafBoundary(root.left, res);
//		leafBoundary(root.right, res);
//		
//	}
	
	// This solution is by RVA. It has more readability, clean and understandble.
    public static ArrayList <Integer> boundaryTraversal(Node root) {
	    ArrayList<Integer> ans = new ArrayList<Integer>(); 
	    ans.add(root.data);
	    
	    addLeftBoundary(root, ans); 
	    addLeaves(root, ans); 
	    addRightBoundary(root, ans); 
	    return ans;
	}
    
    public static Boolean isLeaf(Node root) {
        return (root.left == null) && (root.right == null);
    }
    
    public static void addLeftBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.left;
        while (cur != null) {
            if (isLeaf(cur) == false) res.add(cur.data);
            if (cur.left != null) cur = cur.left;
            else cur = cur.right;
        }
    }
    
    public static void addRightBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.right;
        ArrayList<Integer> tmp = new ArrayList<Integer>();
        
        while (cur != null) {
            if (isLeaf(cur) == false) tmp.add(cur.data);
            if (cur.right != null) cur = cur.right;
            else cur = cur.left;
        }

        for (int i = tmp.size()-1; i >= 0; --i) {
            res.add(tmp.get(i));
        }
    }
    
    public static void addLeaves(Node root, ArrayList<Integer> res) {
        if(root == null) return;
    	
    	if(isLeaf(root)) {
            res.add(root.data);
            return;
        }
        addLeaves(root.left, res);
        addLeaves(root.right, res);
    }
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) {
//			isIdentical[0] = false;
//			return;
//		}
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Solution by RVA.
	public static boolean isSameTree(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree(root1.left, root2.left) && isSameTree(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal. I did this on my own.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-06 15:09:32.171
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-06 15:09:32.172
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-06 15:09:34.199
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 				   / \
		 * 				  69  70
		 * 						\
		 * 						700
		 */
		
		Node root1 = new Node(1);

		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left = new Node(69);
		root1.left.right.right.right = new Node(70);
		root1.left.right.right.right.right = new Node(700);
		
		/**
		 * 					10
		 * 				  /    \
		 * 				 5	   20
		 * 				/ \    / \
		 * 			   3   8  18  25 
		 * 
		 * 
		 */
		
		Node root2 = new Node(10);
		
		root2.left = new Node(5);
		root2.left.right = new Node(8);
		root2.left.right.left = new Node(7);
		root2.left.left = new Node(3);
		
		root2.right = new Node(20);
		root2.right.left = new Node(18);
		root2.right.right = new Node(25);
		
		
		//System.out.println(balancedBinaryTree(root));

		//System.out.println(boundaryTraversal(root2));
		
		//System.out.println(topViewOfBT(root2));
		
		System.out.println(minimumTimeToBurnBT(root1, 4));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	public static int minimumTimeToBurnBT(Node root, int start) {
		HashMap<Node, Node> parent = new HashMap<>();
		Node target = markParent(root, parent);
		
		return burnTree(target, parent);
	}
	
	public static int burnTree()
	
	public static Node markParent(Node root, HashMap<Node, Node> parent) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> distanceK(Node root, Node target, int k ) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		// Child, Parent
		Map<Node, Node> parentTrack = new HashMap<>();
		markParents(root, parentTrack, target);
		
		Map<Node, Boolean> visited = new HashMap<>();
		Queue<Node> q = new LinkedList<>();
		
		q.offer(target);
		visited.put(target, true);
		int curLevel = 0;
		
		while(!q.isEmpty()) {
			int size = q.size();
			
			if(curLevel++ == k) break;
			
			for(int i = 0; i < size; ++i) {
				Node cur = q.poll();
				
				if(cur.left != null && visited.get(cur.left) == null) {
					q.offer(cur.left);
					visited.put(cur.left, true);
				}
				if(cur.right != null && visited.get(cur.right) == null) {
					q.offer(cur.right);
					visited.put(cur.right, true);
				}
				if(parentTrack.get(cur) != null && visited.get(parentTrack.get(cur)) == null) {
					q.offer(parentTrack.get(cur));
					visited.put(parentTrack.get(cur), true);
				}
			}
		}
		
		for(Node i : q) {
			res.add(i.data);
		}
		
		return res;
	}
	
	public static void markParents(Node root, Map<Node, Node> parentTrack, Node target) {
		Queue<Node> q = new LinkedList<>();
		q.offer(root);
		
		while(!q.isEmpty()) {
			Node cur = q.poll();
			
			if(cur.left != null) {
				parentTrack.put(cur.left, cur);
				q.offer(cur.left);
			}
			
			if(cur.right != null) {
				parentTrack.put(cur.right, cur);
				q.offer(cur.right);
			}
		}
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void childrenSumProperty(Node root) {
	// Feeling excited with other 69 PBC because I coded this on my own.
		if(root == null) return;
		
		int rootData = root.data;
		int leftChildData = 0;
		if(root.left != null) leftChildData = root.left.data;
		int rightChildData = 0;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		} else if(leftChildData + rightChildData < rootData) {
			if(root.left != null) root.left.data = root.data;
			if(root.right != null) root.right.data = root.data;
		}
		
		childrenSumProperty(root.left);
		childrenSumProperty(root.right);
		
		if(root.left != null) leftChildData = root.left.data;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		}
	}
	
	public static void maxWidthOfBT(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// brute force approach.
	
//	public static int lowestCommonAncestor(Node root, Node p, Node q) {
//		
//		Set<Integer> pPath = new LinkedHashSet<Integer>();
//		Set<Integer> qPath = new HashSet<Integer>();
//		getPath(root, p.data, pPath);
//		getPath(root, q.data, qPath);
//		
//		System.out.println(pPath.toString());
//		
//		int res = 0;
//		
//		for(Integer i : pPath) {
//			if(qPath.contains(i)) res = i;
//			else break;
//		}
//		
//		return res;
//	}
//	
//	public static boolean getPath(Node root, int n, Set<Integer> res) {
//		if(root == null) return false;
//		
//		res.add(root.data);
//		if(root.data == n) return true;
//		
//		if(getPath(root.left, n, res) || getPath(root.right, n, res)) {
//			return true;
//		}
//		
//		res.remove(root.data);		// Removing last element.
//		return false;
//	}
	
	public static Node lowestCommonAncestor(Node root, Node p, Node q) {
		if(root == null || root == p || root == q) return root;
		
		Node left = lowestCommonAncestor(root.left, p, q);
		Node right = lowestCommonAncestor(root.right, p, q);
		
		if(left == null) return right;
		else if(right == null) return left;
		else return root;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// 1 extra parameter.
	
//	public static LinkedList<Integer> rootToNodePath(Node root, int b) {
//		LinkedList<Integer> res = new LinkedList<>();
//		boolean isNodeFounded[] = {false};
//		solve(root, b, res, isNodeFounded);
//		return res;
//		
//	}
//	
//	public static void solve(Node root, int b, LinkedList<Integer> res, boolean isNodeFounded[]) {
//		if(root == null) return;
//		
//		solve(root.left, b, res, isNodeFounded);
//		if(!isNodeFounded[0]) solve(root.right, b, res, isNodeFounded);
//		if(root.data == b || isNodeFounded[0]) {
//			res.add(0, root.data);
//			isNodeFounded[0] = true;
//		}
//	}
	
	public static ArrayList<Integer> rootToNodePath(Node root, int b) {
		ArrayList<Integer> res = new ArrayList<>();
		solve(root, b, res);
		return res;
	}
	
	public static boolean solve(Node root, int b, ArrayList<Integer> res) {
		if(root == null) return false;
		
		res.add(root.data);
		if(root.data == b) return true;
		
		if(solve(root.left, b, res) || solve(root.right, b, res)) {
			return true;
		}
		
		res.remove(res.size() - 1);		// Removing last element.
		return false;
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	public static boolean symmetricBT(Node root) {
		if(root == null) return true;
		
		return isSymmetric(root.left, root.right);
	}
	
	public static boolean isSymmetric(Node root1, Node root2) {
		if(root1 == null || root2 == null) return root1==root2;
		
		return root1.data == root2.data 
				&& isSymmetric(root1.left, root2.right) 
				&& isSymmetric(root1.right, root2.left);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> rightViewOfBT(Node root) {
		List<Integer> res = new ArrayList<Integer>();
		getRightView(root, res, 0);
		return res;
	}
	
	public static void getRightView(Node root, List<Integer> res, int level) {
		if(root == null) return;
		
		if(level == res.size()) res.add(root.data);
		getRightView(root.right, res, level+1);
		getRightView(root.left, res, level+1);
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	
	// Class required for Bottom view and Top view.
	static class Pair {
		Node root;
		int col;
		public Pair(Node _root, int _col) {
			root = _root;
			col = _col;		// Vertical
		}
	}
	
	public static ArrayList<Integer> bottonViewOfBT(Node root) {
		ArrayList<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.put(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		
		return res;
	}
	
	public static List<Integer> topViewOfBT(Node root) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.putIfAbsent(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	// Class required for Vertical Traversal.
	static class Tuple {
		Node root;
		int row;		// Level
		int col;		// Vertical
		public Tuple(Node _root, int _row, int _col) {
			root = _root;
			row = _row;
			col = _col;
		}
	}
	
	public static List<List<Integer>> verticalTraversal(Node root) {
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		// Vertical, Level
		TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();
		Queue<Tuple> q = new LinkedList<>();
		q.offer(new Tuple(root, 0, 0));
		
		while(!q.isEmpty()) {
			Tuple t = q.poll();
			Node n = t.root;
			int x = t.row;
			int y = t.col;
			
			map.putIfAbsent(y, new TreeMap<>());	// Adding Vertical if absent.
			map.get(y).putIfAbsent(x, new PriorityQueue<>());	// Adding Level if absent.
			
			map.get(y).get(x).offer(n.data);
			
			if(n.left != null) q.offer(new Tuple(n.left, x+1, y-1));
			if(n.right != null) q.offer(new Tuple(n.right, x+1, y+1));
		}
		
		// Traversing over "map" to add node.data to List.
		for(TreeMap<Integer, PriorityQueue<Integer>> ys : map.values()) {
			List<Integer> v = new ArrayList<>();
			for(PriorityQueue<Integer> nodes : ys.values()) {
				while(!nodes.isEmpty()) {
					v.add(nodes.poll());
				}
			}
			res.add(v);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	// Below 4 method is for boundary traversal.
	
	// I coded this whole on my own. Best thing is I did it using recursion.
//	public static ArrayList<Integer> boundaryTraversal(Node root) {
//		ArrayList<Integer> res = new ArrayList<Integer>();
//		if(root == null) return res;
//		
//		res.add(root.data);
//		
//		leftBoundary(root.left, res);
//		leafBoundary(root, res);
//		
//		int size = res.size();
//		rightBoundary(root.right, res, size);
//		
//		return res;
//	}
//	
//	public static void leftBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.left == null) {
//			res.add(root.data);
//			leftBoundary(root.right, res);
//		} else {
//			res.add(root.data);
//			leftBoundary(root.left, res);
//		}
//	}
//	
//	public static void rightBoundary(Node root, ArrayList<Integer> res, int size) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.right == null) {
//			res.add(size, root.data);
//			rightBoundary(root.left, res, size);
//		} else {
//			res.add(size, root.data);
//			rightBoundary(root.right, res, size);
//		}
//	}
//
//	public static void leafBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		
//		if(root.left == null && root.right == null) {
//			res.add(root.data);
//			return;
//		}
//		
//		leafBoundary(root.left, res);
//		leafBoundary(root.right, res);
//		
//	}
	
	// This solution is by RVA. It has more readability, clean and understandble.
    public static ArrayList <Integer> boundaryTraversal(Node root) {
	    ArrayList<Integer> ans = new ArrayList<Integer>(); 
	    ans.add(root.data);
	    
	    addLeftBoundary(root, ans); 
	    addLeaves(root, ans); 
	    addRightBoundary(root, ans); 
	    return ans;
	}
    
    public static Boolean isLeaf(Node root) {
        return (root.left == null) && (root.right == null);
    }
    
    public static void addLeftBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.left;
        while (cur != null) {
            if (isLeaf(cur) == false) res.add(cur.data);
            if (cur.left != null) cur = cur.left;
            else cur = cur.right;
        }
    }
    
    public static void addRightBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.right;
        ArrayList<Integer> tmp = new ArrayList<Integer>();
        
        while (cur != null) {
            if (isLeaf(cur) == false) tmp.add(cur.data);
            if (cur.right != null) cur = cur.right;
            else cur = cur.left;
        }

        for (int i = tmp.size()-1; i >= 0; --i) {
            res.add(tmp.get(i));
        }
    }
    
    public static void addLeaves(Node root, ArrayList<Integer> res) {
        if(root == null) return;
    	
    	if(isLeaf(root)) {
            res.add(root.data);
            return;
        }
        addLeaves(root.left, res);
        addLeaves(root.right, res);
    }
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) {
//			isIdentical[0] = false;
//			return;
//		}
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Solution by RVA.
	public static boolean isSameTree(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree(root1.left, root2.left) && isSameTree(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal. I did this on my own.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-06 15:09:34.201
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-06 15:09:34.202
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-06 15:09:35.229
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 				   / \
		 * 				  69  70
		 * 						\
		 * 						700
		 */
		
		Node root1 = new Node(1);

		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left = new Node(69);
		root1.left.right.right.right = new Node(70);
		root1.left.right.right.right.right = new Node(700);
		
		/**
		 * 					10
		 * 				  /    \
		 * 				 5	   20
		 * 				/ \    / \
		 * 			   3   8  18  25 
		 * 
		 * 
		 */
		
		Node root2 = new Node(10);
		
		root2.left = new Node(5);
		root2.left.right = new Node(8);
		root2.left.right.left = new Node(7);
		root2.left.left = new Node(3);
		
		root2.right = new Node(20);
		root2.right.left = new Node(18);
		root2.right.right = new Node(25);
		
		
		//System.out.println(balancedBinaryTree(root));

		//System.out.println(boundaryTraversal(root2));
		
		//System.out.println(topViewOfBT(root2));
		
		System.out.println(minimumTimeToBurnBT(root1, 4));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	public static int minimumTimeToBurnBT(Node root, int start) {
		HashMap<Node, Node> parent = new HashMap<>();
		Node target = markParent(root, parent);
		
		return burnTree(target, parent);
	}
	
	public static int burnTree(No)
	
	public static Node markParent(Node root, HashMap<Node, Node> parent) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> distanceK(Node root, Node target, int k ) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		// Child, Parent
		Map<Node, Node> parentTrack = new HashMap<>();
		markParents(root, parentTrack, target);
		
		Map<Node, Boolean> visited = new HashMap<>();
		Queue<Node> q = new LinkedList<>();
		
		q.offer(target);
		visited.put(target, true);
		int curLevel = 0;
		
		while(!q.isEmpty()) {
			int size = q.size();
			
			if(curLevel++ == k) break;
			
			for(int i = 0; i < size; ++i) {
				Node cur = q.poll();
				
				if(cur.left != null && visited.get(cur.left) == null) {
					q.offer(cur.left);
					visited.put(cur.left, true);
				}
				if(cur.right != null && visited.get(cur.right) == null) {
					q.offer(cur.right);
					visited.put(cur.right, true);
				}
				if(parentTrack.get(cur) != null && visited.get(parentTrack.get(cur)) == null) {
					q.offer(parentTrack.get(cur));
					visited.put(parentTrack.get(cur), true);
				}
			}
		}
		
		for(Node i : q) {
			res.add(i.data);
		}
		
		return res;
	}
	
	public static void markParents(Node root, Map<Node, Node> parentTrack, Node target) {
		Queue<Node> q = new LinkedList<>();
		q.offer(root);
		
		while(!q.isEmpty()) {
			Node cur = q.poll();
			
			if(cur.left != null) {
				parentTrack.put(cur.left, cur);
				q.offer(cur.left);
			}
			
			if(cur.right != null) {
				parentTrack.put(cur.right, cur);
				q.offer(cur.right);
			}
		}
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void childrenSumProperty(Node root) {
	// Feeling excited with other 69 PBC because I coded this on my own.
		if(root == null) return;
		
		int rootData = root.data;
		int leftChildData = 0;
		if(root.left != null) leftChildData = root.left.data;
		int rightChildData = 0;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		} else if(leftChildData + rightChildData < rootData) {
			if(root.left != null) root.left.data = root.data;
			if(root.right != null) root.right.data = root.data;
		}
		
		childrenSumProperty(root.left);
		childrenSumProperty(root.right);
		
		if(root.left != null) leftChildData = root.left.data;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		}
	}
	
	public static void maxWidthOfBT(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// brute force approach.
	
//	public static int lowestCommonAncestor(Node root, Node p, Node q) {
//		
//		Set<Integer> pPath = new LinkedHashSet<Integer>();
//		Set<Integer> qPath = new HashSet<Integer>();
//		getPath(root, p.data, pPath);
//		getPath(root, q.data, qPath);
//		
//		System.out.println(pPath.toString());
//		
//		int res = 0;
//		
//		for(Integer i : pPath) {
//			if(qPath.contains(i)) res = i;
//			else break;
//		}
//		
//		return res;
//	}
//	
//	public static boolean getPath(Node root, int n, Set<Integer> res) {
//		if(root == null) return false;
//		
//		res.add(root.data);
//		if(root.data == n) return true;
//		
//		if(getPath(root.left, n, res) || getPath(root.right, n, res)) {
//			return true;
//		}
//		
//		res.remove(root.data);		// Removing last element.
//		return false;
//	}
	
	public static Node lowestCommonAncestor(Node root, Node p, Node q) {
		if(root == null || root == p || root == q) return root;
		
		Node left = lowestCommonAncestor(root.left, p, q);
		Node right = lowestCommonAncestor(root.right, p, q);
		
		if(left == null) return right;
		else if(right == null) return left;
		else return root;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// 1 extra parameter.
	
//	public static LinkedList<Integer> rootToNodePath(Node root, int b) {
//		LinkedList<Integer> res = new LinkedList<>();
//		boolean isNodeFounded[] = {false};
//		solve(root, b, res, isNodeFounded);
//		return res;
//		
//	}
//	
//	public static void solve(Node root, int b, LinkedList<Integer> res, boolean isNodeFounded[]) {
//		if(root == null) return;
//		
//		solve(root.left, b, res, isNodeFounded);
//		if(!isNodeFounded[0]) solve(root.right, b, res, isNodeFounded);
//		if(root.data == b || isNodeFounded[0]) {
//			res.add(0, root.data);
//			isNodeFounded[0] = true;
//		}
//	}
	
	public static ArrayList<Integer> rootToNodePath(Node root, int b) {
		ArrayList<Integer> res = new ArrayList<>();
		solve(root, b, res);
		return res;
	}
	
	public static boolean solve(Node root, int b, ArrayList<Integer> res) {
		if(root == null) return false;
		
		res.add(root.data);
		if(root.data == b) return true;
		
		if(solve(root.left, b, res) || solve(root.right, b, res)) {
			return true;
		}
		
		res.remove(res.size() - 1);		// Removing last element.
		return false;
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	public static boolean symmetricBT(Node root) {
		if(root == null) return true;
		
		return isSymmetric(root.left, root.right);
	}
	
	public static boolean isSymmetric(Node root1, Node root2) {
		if(root1 == null || root2 == null) return root1==root2;
		
		return root1.data == root2.data 
				&& isSymmetric(root1.left, root2.right) 
				&& isSymmetric(root1.right, root2.left);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> rightViewOfBT(Node root) {
		List<Integer> res = new ArrayList<Integer>();
		getRightView(root, res, 0);
		return res;
	}
	
	public static void getRightView(Node root, List<Integer> res, int level) {
		if(root == null) return;
		
		if(level == res.size()) res.add(root.data);
		getRightView(root.right, res, level+1);
		getRightView(root.left, res, level+1);
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	
	// Class required for Bottom view and Top view.
	static class Pair {
		Node root;
		int col;
		public Pair(Node _root, int _col) {
			root = _root;
			col = _col;		// Vertical
		}
	}
	
	public static ArrayList<Integer> bottonViewOfBT(Node root) {
		ArrayList<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.put(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		
		return res;
	}
	
	public static List<Integer> topViewOfBT(Node root) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.putIfAbsent(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	// Class required for Vertical Traversal.
	static class Tuple {
		Node root;
		int row;		// Level
		int col;		// Vertical
		public Tuple(Node _root, int _row, int _col) {
			root = _root;
			row = _row;
			col = _col;
		}
	}
	
	public static List<List<Integer>> verticalTraversal(Node root) {
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		// Vertical, Level
		TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();
		Queue<Tuple> q = new LinkedList<>();
		q.offer(new Tuple(root, 0, 0));
		
		while(!q.isEmpty()) {
			Tuple t = q.poll();
			Node n = t.root;
			int x = t.row;
			int y = t.col;
			
			map.putIfAbsent(y, new TreeMap<>());	// Adding Vertical if absent.
			map.get(y).putIfAbsent(x, new PriorityQueue<>());	// Adding Level if absent.
			
			map.get(y).get(x).offer(n.data);
			
			if(n.left != null) q.offer(new Tuple(n.left, x+1, y-1));
			if(n.right != null) q.offer(new Tuple(n.right, x+1, y+1));
		}
		
		// Traversing over "map" to add node.data to List.
		for(TreeMap<Integer, PriorityQueue<Integer>> ys : map.values()) {
			List<Integer> v = new ArrayList<>();
			for(PriorityQueue<Integer> nodes : ys.values()) {
				while(!nodes.isEmpty()) {
					v.add(nodes.poll());
				}
			}
			res.add(v);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	// Below 4 method is for boundary traversal.
	
	// I coded this whole on my own. Best thing is I did it using recursion.
//	public static ArrayList<Integer> boundaryTraversal(Node root) {
//		ArrayList<Integer> res = new ArrayList<Integer>();
//		if(root == null) return res;
//		
//		res.add(root.data);
//		
//		leftBoundary(root.left, res);
//		leafBoundary(root, res);
//		
//		int size = res.size();
//		rightBoundary(root.right, res, size);
//		
//		return res;
//	}
//	
//	public static void leftBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.left == null) {
//			res.add(root.data);
//			leftBoundary(root.right, res);
//		} else {
//			res.add(root.data);
//			leftBoundary(root.left, res);
//		}
//	}
//	
//	public static void rightBoundary(Node root, ArrayList<Integer> res, int size) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.right == null) {
//			res.add(size, root.data);
//			rightBoundary(root.left, res, size);
//		} else {
//			res.add(size, root.data);
//			rightBoundary(root.right, res, size);
//		}
//	}
//
//	public static void leafBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		
//		if(root.left == null && root.right == null) {
//			res.add(root.data);
//			return;
//		}
//		
//		leafBoundary(root.left, res);
//		leafBoundary(root.right, res);
//		
//	}
	
	// This solution is by RVA. It has more readability, clean and understandble.
    public static ArrayList <Integer> boundaryTraversal(Node root) {
	    ArrayList<Integer> ans = new ArrayList<Integer>(); 
	    ans.add(root.data);
	    
	    addLeftBoundary(root, ans); 
	    addLeaves(root, ans); 
	    addRightBoundary(root, ans); 
	    return ans;
	}
    
    public static Boolean isLeaf(Node root) {
        return (root.left == null) && (root.right == null);
    }
    
    public static void addLeftBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.left;
        while (cur != null) {
            if (isLeaf(cur) == false) res.add(cur.data);
            if (cur.left != null) cur = cur.left;
            else cur = cur.right;
        }
    }
    
    public static void addRightBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.right;
        ArrayList<Integer> tmp = new ArrayList<Integer>();
        
        while (cur != null) {
            if (isLeaf(cur) == false) tmp.add(cur.data);
            if (cur.right != null) cur = cur.right;
            else cur = cur.left;
        }

        for (int i = tmp.size()-1; i >= 0; --i) {
            res.add(tmp.get(i));
        }
    }
    
    public static void addLeaves(Node root, ArrayList<Integer> res) {
        if(root == null) return;
    	
    	if(isLeaf(root)) {
            res.add(root.data);
            return;
        }
        addLeaves(root.left, res);
        addLeaves(root.right, res);
    }
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) {
//			isIdentical[0] = false;
//			return;
//		}
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Solution by RVA.
	public static boolean isSameTree(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree(root1.left, root2.left) && isSameTree(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal. I did this on my own.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-06 15:09:35.229
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-06 15:09:35.230
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-06 15:09:38.752
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 				   / \
		 * 				  69  70
		 * 						\
		 * 						700
		 */
		
		Node root1 = new Node(1);

		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left = new Node(69);
		root1.left.right.right.right = new Node(70);
		root1.left.right.right.right.right = new Node(700);
		
		/**
		 * 					10
		 * 				  /    \
		 * 				 5	   20
		 * 				/ \    / \
		 * 			   3   8  18  25 
		 * 
		 * 
		 */
		
		Node root2 = new Node(10);
		
		root2.left = new Node(5);
		root2.left.right = new Node(8);
		root2.left.right.left = new Node(7);
		root2.left.left = new Node(3);
		
		root2.right = new Node(20);
		root2.right.left = new Node(18);
		root2.right.right = new Node(25);
		
		
		//System.out.println(balancedBinaryTree(root));

		//System.out.println(boundaryTraversal(root2));
		
		//System.out.println(topViewOfBT(root2));
		
		System.out.println(minimumTimeToBurnBT(root1, 4));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	public static int minimumTimeToBurnBT(Node root, int start) {
		HashMap<Node, Node> parent = new HashMap<>();
		Node target = markParent(root, parent);
		
		return burnTree(target, parent);
	}
	
	public static int burnTree(Node target, )
	
	public static Node markParent(Node root, HashMap<Node, Node> parent) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> distanceK(Node root, Node target, int k ) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		// Child, Parent
		Map<Node, Node> parentTrack = new HashMap<>();
		markParents(root, parentTrack, target);
		
		Map<Node, Boolean> visited = new HashMap<>();
		Queue<Node> q = new LinkedList<>();
		
		q.offer(target);
		visited.put(target, true);
		int curLevel = 0;
		
		while(!q.isEmpty()) {
			int size = q.size();
			
			if(curLevel++ == k) break;
			
			for(int i = 0; i < size; ++i) {
				Node cur = q.poll();
				
				if(cur.left != null && visited.get(cur.left) == null) {
					q.offer(cur.left);
					visited.put(cur.left, true);
				}
				if(cur.right != null && visited.get(cur.right) == null) {
					q.offer(cur.right);
					visited.put(cur.right, true);
				}
				if(parentTrack.get(cur) != null && visited.get(parentTrack.get(cur)) == null) {
					q.offer(parentTrack.get(cur));
					visited.put(parentTrack.get(cur), true);
				}
			}
		}
		
		for(Node i : q) {
			res.add(i.data);
		}
		
		return res;
	}
	
	public static void markParents(Node root, Map<Node, Node> parentTrack, Node target) {
		Queue<Node> q = new LinkedList<>();
		q.offer(root);
		
		while(!q.isEmpty()) {
			Node cur = q.poll();
			
			if(cur.left != null) {
				parentTrack.put(cur.left, cur);
				q.offer(cur.left);
			}
			
			if(cur.right != null) {
				parentTrack.put(cur.right, cur);
				q.offer(cur.right);
			}
		}
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void childrenSumProperty(Node root) {
	// Feeling excited with other 69 PBC because I coded this on my own.
		if(root == null) return;
		
		int rootData = root.data;
		int leftChildData = 0;
		if(root.left != null) leftChildData = root.left.data;
		int rightChildData = 0;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		} else if(leftChildData + rightChildData < rootData) {
			if(root.left != null) root.left.data = root.data;
			if(root.right != null) root.right.data = root.data;
		}
		
		childrenSumProperty(root.left);
		childrenSumProperty(root.right);
		
		if(root.left != null) leftChildData = root.left.data;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		}
	}
	
	public static void maxWidthOfBT(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// brute force approach.
	
//	public static int lowestCommonAncestor(Node root, Node p, Node q) {
//		
//		Set<Integer> pPath = new LinkedHashSet<Integer>();
//		Set<Integer> qPath = new HashSet<Integer>();
//		getPath(root, p.data, pPath);
//		getPath(root, q.data, qPath);
//		
//		System.out.println(pPath.toString());
//		
//		int res = 0;
//		
//		for(Integer i : pPath) {
//			if(qPath.contains(i)) res = i;
//			else break;
//		}
//		
//		return res;
//	}
//	
//	public static boolean getPath(Node root, int n, Set<Integer> res) {
//		if(root == null) return false;
//		
//		res.add(root.data);
//		if(root.data == n) return true;
//		
//		if(getPath(root.left, n, res) || getPath(root.right, n, res)) {
//			return true;
//		}
//		
//		res.remove(root.data);		// Removing last element.
//		return false;
//	}
	
	public static Node lowestCommonAncestor(Node root, Node p, Node q) {
		if(root == null || root == p || root == q) return root;
		
		Node left = lowestCommonAncestor(root.left, p, q);
		Node right = lowestCommonAncestor(root.right, p, q);
		
		if(left == null) return right;
		else if(right == null) return left;
		else return root;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// 1 extra parameter.
	
//	public static LinkedList<Integer> rootToNodePath(Node root, int b) {
//		LinkedList<Integer> res = new LinkedList<>();
//		boolean isNodeFounded[] = {false};
//		solve(root, b, res, isNodeFounded);
//		return res;
//		
//	}
//	
//	public static void solve(Node root, int b, LinkedList<Integer> res, boolean isNodeFounded[]) {
//		if(root == null) return;
//		
//		solve(root.left, b, res, isNodeFounded);
//		if(!isNodeFounded[0]) solve(root.right, b, res, isNodeFounded);
//		if(root.data == b || isNodeFounded[0]) {
//			res.add(0, root.data);
//			isNodeFounded[0] = true;
//		}
//	}
	
	public static ArrayList<Integer> rootToNodePath(Node root, int b) {
		ArrayList<Integer> res = new ArrayList<>();
		solve(root, b, res);
		return res;
	}
	
	public static boolean solve(Node root, int b, ArrayList<Integer> res) {
		if(root == null) return false;
		
		res.add(root.data);
		if(root.data == b) return true;
		
		if(solve(root.left, b, res) || solve(root.right, b, res)) {
			return true;
		}
		
		res.remove(res.size() - 1);		// Removing last element.
		return false;
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	public static boolean symmetricBT(Node root) {
		if(root == null) return true;
		
		return isSymmetric(root.left, root.right);
	}
	
	public static boolean isSymmetric(Node root1, Node root2) {
		if(root1 == null || root2 == null) return root1==root2;
		
		return root1.data == root2.data 
				&& isSymmetric(root1.left, root2.right) 
				&& isSymmetric(root1.right, root2.left);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> rightViewOfBT(Node root) {
		List<Integer> res = new ArrayList<Integer>();
		getRightView(root, res, 0);
		return res;
	}
	
	public static void getRightView(Node root, List<Integer> res, int level) {
		if(root == null) return;
		
		if(level == res.size()) res.add(root.data);
		getRightView(root.right, res, level+1);
		getRightView(root.left, res, level+1);
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	
	// Class required for Bottom view and Top view.
	static class Pair {
		Node root;
		int col;
		public Pair(Node _root, int _col) {
			root = _root;
			col = _col;		// Vertical
		}
	}
	
	public static ArrayList<Integer> bottonViewOfBT(Node root) {
		ArrayList<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.put(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		
		return res;
	}
	
	public static List<Integer> topViewOfBT(Node root) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.putIfAbsent(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	// Class required for Vertical Traversal.
	static class Tuple {
		Node root;
		int row;		// Level
		int col;		// Vertical
		public Tuple(Node _root, int _row, int _col) {
			root = _root;
			row = _row;
			col = _col;
		}
	}
	
	public static List<List<Integer>> verticalTraversal(Node root) {
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		// Vertical, Level
		TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();
		Queue<Tuple> q = new LinkedList<>();
		q.offer(new Tuple(root, 0, 0));
		
		while(!q.isEmpty()) {
			Tuple t = q.poll();
			Node n = t.root;
			int x = t.row;
			int y = t.col;
			
			map.putIfAbsent(y, new TreeMap<>());	// Adding Vertical if absent.
			map.get(y).putIfAbsent(x, new PriorityQueue<>());	// Adding Level if absent.
			
			map.get(y).get(x).offer(n.data);
			
			if(n.left != null) q.offer(new Tuple(n.left, x+1, y-1));
			if(n.right != null) q.offer(new Tuple(n.right, x+1, y+1));
		}
		
		// Traversing over "map" to add node.data to List.
		for(TreeMap<Integer, PriorityQueue<Integer>> ys : map.values()) {
			List<Integer> v = new ArrayList<>();
			for(PriorityQueue<Integer> nodes : ys.values()) {
				while(!nodes.isEmpty()) {
					v.add(nodes.poll());
				}
			}
			res.add(v);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	// Below 4 method is for boundary traversal.
	
	// I coded this whole on my own. Best thing is I did it using recursion.
//	public static ArrayList<Integer> boundaryTraversal(Node root) {
//		ArrayList<Integer> res = new ArrayList<Integer>();
//		if(root == null) return res;
//		
//		res.add(root.data);
//		
//		leftBoundary(root.left, res);
//		leafBoundary(root, res);
//		
//		int size = res.size();
//		rightBoundary(root.right, res, size);
//		
//		return res;
//	}
//	
//	public static void leftBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.left == null) {
//			res.add(root.data);
//			leftBoundary(root.right, res);
//		} else {
//			res.add(root.data);
//			leftBoundary(root.left, res);
//		}
//	}
//	
//	public static void rightBoundary(Node root, ArrayList<Integer> res, int size) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.right == null) {
//			res.add(size, root.data);
//			rightBoundary(root.left, res, size);
//		} else {
//			res.add(size, root.data);
//			rightBoundary(root.right, res, size);
//		}
//	}
//
//	public static void leafBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		
//		if(root.left == null && root.right == null) {
//			res.add(root.data);
//			return;
//		}
//		
//		leafBoundary(root.left, res);
//		leafBoundary(root.right, res);
//		
//	}
	
	// This solution is by RVA. It has more readability, clean and understandble.
    public static ArrayList <Integer> boundaryTraversal(Node root) {
	    ArrayList<Integer> ans = new ArrayList<Integer>(); 
	    ans.add(root.data);
	    
	    addLeftBoundary(root, ans); 
	    addLeaves(root, ans); 
	    addRightBoundary(root, ans); 
	    return ans;
	}
    
    public static Boolean isLeaf(Node root) {
        return (root.left == null) && (root.right == null);
    }
    
    public static void addLeftBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.left;
        while (cur != null) {
            if (isLeaf(cur) == false) res.add(cur.data);
            if (cur.left != null) cur = cur.left;
            else cur = cur.right;
        }
    }
    
    public static void addRightBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.right;
        ArrayList<Integer> tmp = new ArrayList<Integer>();
        
        while (cur != null) {
            if (isLeaf(cur) == false) tmp.add(cur.data);
            if (cur.right != null) cur = cur.right;
            else cur = cur.left;
        }

        for (int i = tmp.size()-1; i >= 0; --i) {
            res.add(tmp.get(i));
        }
    }
    
    public static void addLeaves(Node root, ArrayList<Integer> res) {
        if(root == null) return;
    	
    	if(isLeaf(root)) {
            res.add(root.data);
            return;
        }
        addLeaves(root.left, res);
        addLeaves(root.right, res);
    }
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) {
//			isIdentical[0] = false;
//			return;
//		}
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Solution by RVA.
	public static boolean isSameTree(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree(root1.left, root2.left) && isSameTree(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal. I did this on my own.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-06 15:09:38.753
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-06 15:09:38.753
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-06 15:09:40.282
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 				   / \
		 * 				  69  70
		 * 						\
		 * 						700
		 */
		
		Node root1 = new Node(1);

		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left = new Node(69);
		root1.left.right.right.right = new Node(70);
		root1.left.right.right.right.right = new Node(700);
		
		/**
		 * 					10
		 * 				  /    \
		 * 				 5	   20
		 * 				/ \    / \
		 * 			   3   8  18  25 
		 * 
		 * 
		 */
		
		Node root2 = new Node(10);
		
		root2.left = new Node(5);
		root2.left.right = new Node(8);
		root2.left.right.left = new Node(7);
		root2.left.left = new Node(3);
		
		root2.right = new Node(20);
		root2.right.left = new Node(18);
		root2.right.right = new Node(25);
		
		
		//System.out.println(balancedBinaryTree(root));

		//System.out.println(boundaryTraversal(root2));
		
		//System.out.println(topViewOfBT(root2));
		
		System.out.println(minimumTimeToBurnBT(root1, 4));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	public static int minimumTimeToBurnBT(Node root, int start) {
		HashMap<Node, Node> parent = new HashMap<>();
		Node target = markParent(root, parent);
		
		return burnTree(target, parent);
	}
	
	public static int burnTree(Node target, Hash)
	
	public static Node markParent(Node root, HashMap<Node, Node> parent) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> distanceK(Node root, Node target, int k ) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		// Child, Parent
		Map<Node, Node> parentTrack = new HashMap<>();
		markParents(root, parentTrack, target);
		
		Map<Node, Boolean> visited = new HashMap<>();
		Queue<Node> q = new LinkedList<>();
		
		q.offer(target);
		visited.put(target, true);
		int curLevel = 0;
		
		while(!q.isEmpty()) {
			int size = q.size();
			
			if(curLevel++ == k) break;
			
			for(int i = 0; i < size; ++i) {
				Node cur = q.poll();
				
				if(cur.left != null && visited.get(cur.left) == null) {
					q.offer(cur.left);
					visited.put(cur.left, true);
				}
				if(cur.right != null && visited.get(cur.right) == null) {
					q.offer(cur.right);
					visited.put(cur.right, true);
				}
				if(parentTrack.get(cur) != null && visited.get(parentTrack.get(cur)) == null) {
					q.offer(parentTrack.get(cur));
					visited.put(parentTrack.get(cur), true);
				}
			}
		}
		
		for(Node i : q) {
			res.add(i.data);
		}
		
		return res;
	}
	
	public static void markParents(Node root, Map<Node, Node> parentTrack, Node target) {
		Queue<Node> q = new LinkedList<>();
		q.offer(root);
		
		while(!q.isEmpty()) {
			Node cur = q.poll();
			
			if(cur.left != null) {
				parentTrack.put(cur.left, cur);
				q.offer(cur.left);
			}
			
			if(cur.right != null) {
				parentTrack.put(cur.right, cur);
				q.offer(cur.right);
			}
		}
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void childrenSumProperty(Node root) {
	// Feeling excited with other 69 PBC because I coded this on my own.
		if(root == null) return;
		
		int rootData = root.data;
		int leftChildData = 0;
		if(root.left != null) leftChildData = root.left.data;
		int rightChildData = 0;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		} else if(leftChildData + rightChildData < rootData) {
			if(root.left != null) root.left.data = root.data;
			if(root.right != null) root.right.data = root.data;
		}
		
		childrenSumProperty(root.left);
		childrenSumProperty(root.right);
		
		if(root.left != null) leftChildData = root.left.data;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		}
	}
	
	public static void maxWidthOfBT(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// brute force approach.
	
//	public static int lowestCommonAncestor(Node root, Node p, Node q) {
//		
//		Set<Integer> pPath = new LinkedHashSet<Integer>();
//		Set<Integer> qPath = new HashSet<Integer>();
//		getPath(root, p.data, pPath);
//		getPath(root, q.data, qPath);
//		
//		System.out.println(pPath.toString());
//		
//		int res = 0;
//		
//		for(Integer i : pPath) {
//			if(qPath.contains(i)) res = i;
//			else break;
//		}
//		
//		return res;
//	}
//	
//	public static boolean getPath(Node root, int n, Set<Integer> res) {
//		if(root == null) return false;
//		
//		res.add(root.data);
//		if(root.data == n) return true;
//		
//		if(getPath(root.left, n, res) || getPath(root.right, n, res)) {
//			return true;
//		}
//		
//		res.remove(root.data);		// Removing last element.
//		return false;
//	}
	
	public static Node lowestCommonAncestor(Node root, Node p, Node q) {
		if(root == null || root == p || root == q) return root;
		
		Node left = lowestCommonAncestor(root.left, p, q);
		Node right = lowestCommonAncestor(root.right, p, q);
		
		if(left == null) return right;
		else if(right == null) return left;
		else return root;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// 1 extra parameter.
	
//	public static LinkedList<Integer> rootToNodePath(Node root, int b) {
//		LinkedList<Integer> res = new LinkedList<>();
//		boolean isNodeFounded[] = {false};
//		solve(root, b, res, isNodeFounded);
//		return res;
//		
//	}
//	
//	public static void solve(Node root, int b, LinkedList<Integer> res, boolean isNodeFounded[]) {
//		if(root == null) return;
//		
//		solve(root.left, b, res, isNodeFounded);
//		if(!isNodeFounded[0]) solve(root.right, b, res, isNodeFounded);
//		if(root.data == b || isNodeFounded[0]) {
//			res.add(0, root.data);
//			isNodeFounded[0] = true;
//		}
//	}
	
	public static ArrayList<Integer> rootToNodePath(Node root, int b) {
		ArrayList<Integer> res = new ArrayList<>();
		solve(root, b, res);
		return res;
	}
	
	public static boolean solve(Node root, int b, ArrayList<Integer> res) {
		if(root == null) return false;
		
		res.add(root.data);
		if(root.data == b) return true;
		
		if(solve(root.left, b, res) || solve(root.right, b, res)) {
			return true;
		}
		
		res.remove(res.size() - 1);		// Removing last element.
		return false;
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	public static boolean symmetricBT(Node root) {
		if(root == null) return true;
		
		return isSymmetric(root.left, root.right);
	}
	
	public static boolean isSymmetric(Node root1, Node root2) {
		if(root1 == null || root2 == null) return root1==root2;
		
		return root1.data == root2.data 
				&& isSymmetric(root1.left, root2.right) 
				&& isSymmetric(root1.right, root2.left);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> rightViewOfBT(Node root) {
		List<Integer> res = new ArrayList<Integer>();
		getRightView(root, res, 0);
		return res;
	}
	
	public static void getRightView(Node root, List<Integer> res, int level) {
		if(root == null) return;
		
		if(level == res.size()) res.add(root.data);
		getRightView(root.right, res, level+1);
		getRightView(root.left, res, level+1);
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	
	// Class required for Bottom view and Top view.
	static class Pair {
		Node root;
		int col;
		public Pair(Node _root, int _col) {
			root = _root;
			col = _col;		// Vertical
		}
	}
	
	public static ArrayList<Integer> bottonViewOfBT(Node root) {
		ArrayList<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.put(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		
		return res;
	}
	
	public static List<Integer> topViewOfBT(Node root) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.putIfAbsent(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	// Class required for Vertical Traversal.
	static class Tuple {
		Node root;
		int row;		// Level
		int col;		// Vertical
		public Tuple(Node _root, int _row, int _col) {
			root = _root;
			row = _row;
			col = _col;
		}
	}
	
	public static List<List<Integer>> verticalTraversal(Node root) {
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		// Vertical, Level
		TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();
		Queue<Tuple> q = new LinkedList<>();
		q.offer(new Tuple(root, 0, 0));
		
		while(!q.isEmpty()) {
			Tuple t = q.poll();
			Node n = t.root;
			int x = t.row;
			int y = t.col;
			
			map.putIfAbsent(y, new TreeMap<>());	// Adding Vertical if absent.
			map.get(y).putIfAbsent(x, new PriorityQueue<>());	// Adding Level if absent.
			
			map.get(y).get(x).offer(n.data);
			
			if(n.left != null) q.offer(new Tuple(n.left, x+1, y-1));
			if(n.right != null) q.offer(new Tuple(n.right, x+1, y+1));
		}
		
		// Traversing over "map" to add node.data to List.
		for(TreeMap<Integer, PriorityQueue<Integer>> ys : map.values()) {
			List<Integer> v = new ArrayList<>();
			for(PriorityQueue<Integer> nodes : ys.values()) {
				while(!nodes.isEmpty()) {
					v.add(nodes.poll());
				}
			}
			res.add(v);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	// Below 4 method is for boundary traversal.
	
	// I coded this whole on my own. Best thing is I did it using recursion.
//	public static ArrayList<Integer> boundaryTraversal(Node root) {
//		ArrayList<Integer> res = new ArrayList<Integer>();
//		if(root == null) return res;
//		
//		res.add(root.data);
//		
//		leftBoundary(root.left, res);
//		leafBoundary(root, res);
//		
//		int size = res.size();
//		rightBoundary(root.right, res, size);
//		
//		return res;
//	}
//	
//	public static void leftBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.left == null) {
//			res.add(root.data);
//			leftBoundary(root.right, res);
//		} else {
//			res.add(root.data);
//			leftBoundary(root.left, res);
//		}
//	}
//	
//	public static void rightBoundary(Node root, ArrayList<Integer> res, int size) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.right == null) {
//			res.add(size, root.data);
//			rightBoundary(root.left, res, size);
//		} else {
//			res.add(size, root.data);
//			rightBoundary(root.right, res, size);
//		}
//	}
//
//	public static void leafBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		
//		if(root.left == null && root.right == null) {
//			res.add(root.data);
//			return;
//		}
//		
//		leafBoundary(root.left, res);
//		leafBoundary(root.right, res);
//		
//	}
	
	// This solution is by RVA. It has more readability, clean and understandble.
    public static ArrayList <Integer> boundaryTraversal(Node root) {
	    ArrayList<Integer> ans = new ArrayList<Integer>(); 
	    ans.add(root.data);
	    
	    addLeftBoundary(root, ans); 
	    addLeaves(root, ans); 
	    addRightBoundary(root, ans); 
	    return ans;
	}
    
    public static Boolean isLeaf(Node root) {
        return (root.left == null) && (root.right == null);
    }
    
    public static void addLeftBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.left;
        while (cur != null) {
            if (isLeaf(cur) == false) res.add(cur.data);
            if (cur.left != null) cur = cur.left;
            else cur = cur.right;
        }
    }
    
    public static void addRightBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.right;
        ArrayList<Integer> tmp = new ArrayList<Integer>();
        
        while (cur != null) {
            if (isLeaf(cur) == false) tmp.add(cur.data);
            if (cur.right != null) cur = cur.right;
            else cur = cur.left;
        }

        for (int i = tmp.size()-1; i >= 0; --i) {
            res.add(tmp.get(i));
        }
    }
    
    public static void addLeaves(Node root, ArrayList<Integer> res) {
        if(root == null) return;
    	
    	if(isLeaf(root)) {
            res.add(root.data);
            return;
        }
        addLeaves(root.left, res);
        addLeaves(root.right, res);
    }
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) {
//			isIdentical[0] = false;
//			return;
//		}
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Solution by RVA.
	public static boolean isSameTree(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree(root1.left, root2.left) && isSameTree(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal. I did this on my own.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-06 15:09:40.283
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-06 15:09:40.283
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-06 15:09:45.816
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 				   / \
		 * 				  69  70
		 * 						\
		 * 						700
		 */
		
		Node root1 = new Node(1);

		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left = new Node(69);
		root1.left.right.right.right = new Node(70);
		root1.left.right.right.right.right = new Node(700);
		
		/**
		 * 					10
		 * 				  /    \
		 * 				 5	   20
		 * 				/ \    / \
		 * 			   3   8  18  25 
		 * 
		 * 
		 */
		
		Node root2 = new Node(10);
		
		root2.left = new Node(5);
		root2.left.right = new Node(8);
		root2.left.right.left = new Node(7);
		root2.left.left = new Node(3);
		
		root2.right = new Node(20);
		root2.right.left = new Node(18);
		root2.right.right = new Node(25);
		
		
		//System.out.println(balancedBinaryTree(root));

		//System.out.println(boundaryTraversal(root2));
		
		//System.out.println(topViewOfBT(root2));
		
		System.out.println(minimumTimeToBurnBT(root1, 4));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	public static int minimumTimeToBurnBT(Node root, int start) {
		HashMap<Node, Node> parent = new HashMap<>();
		Node target = markParent(root, parent);
		
		return burnTree(target, parent);
	}
	
	public static int burnTree(Node target, HashMap<n>)
	
	public static Node markParent(Node root, HashMap<Node, Node> parent) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> distanceK(Node root, Node target, int k ) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		// Child, Parent
		Map<Node, Node> parentTrack = new HashMap<>();
		markParents(root, parentTrack, target);
		
		Map<Node, Boolean> visited = new HashMap<>();
		Queue<Node> q = new LinkedList<>();
		
		q.offer(target);
		visited.put(target, true);
		int curLevel = 0;
		
		while(!q.isEmpty()) {
			int size = q.size();
			
			if(curLevel++ == k) break;
			
			for(int i = 0; i < size; ++i) {
				Node cur = q.poll();
				
				if(cur.left != null && visited.get(cur.left) == null) {
					q.offer(cur.left);
					visited.put(cur.left, true);
				}
				if(cur.right != null && visited.get(cur.right) == null) {
					q.offer(cur.right);
					visited.put(cur.right, true);
				}
				if(parentTrack.get(cur) != null && visited.get(parentTrack.get(cur)) == null) {
					q.offer(parentTrack.get(cur));
					visited.put(parentTrack.get(cur), true);
				}
			}
		}
		
		for(Node i : q) {
			res.add(i.data);
		}
		
		return res;
	}
	
	public static void markParents(Node root, Map<Node, Node> parentTrack, Node target) {
		Queue<Node> q = new LinkedList<>();
		q.offer(root);
		
		while(!q.isEmpty()) {
			Node cur = q.poll();
			
			if(cur.left != null) {
				parentTrack.put(cur.left, cur);
				q.offer(cur.left);
			}
			
			if(cur.right != null) {
				parentTrack.put(cur.right, cur);
				q.offer(cur.right);
			}
		}
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void childrenSumProperty(Node root) {
	// Feeling excited with other 69 PBC because I coded this on my own.
		if(root == null) return;
		
		int rootData = root.data;
		int leftChildData = 0;
		if(root.left != null) leftChildData = root.left.data;
		int rightChildData = 0;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		} else if(leftChildData + rightChildData < rootData) {
			if(root.left != null) root.left.data = root.data;
			if(root.right != null) root.right.data = root.data;
		}
		
		childrenSumProperty(root.left);
		childrenSumProperty(root.right);
		
		if(root.left != null) leftChildData = root.left.data;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		}
	}
	
	public static void maxWidthOfBT(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// brute force approach.
	
//	public static int lowestCommonAncestor(Node root, Node p, Node q) {
//		
//		Set<Integer> pPath = new LinkedHashSet<Integer>();
//		Set<Integer> qPath = new HashSet<Integer>();
//		getPath(root, p.data, pPath);
//		getPath(root, q.data, qPath);
//		
//		System.out.println(pPath.toString());
//		
//		int res = 0;
//		
//		for(Integer i : pPath) {
//			if(qPath.contains(i)) res = i;
//			else break;
//		}
//		
//		return res;
//	}
//	
//	public static boolean getPath(Node root, int n, Set<Integer> res) {
//		if(root == null) return false;
//		
//		res.add(root.data);
//		if(root.data == n) return true;
//		
//		if(getPath(root.left, n, res) || getPath(root.right, n, res)) {
//			return true;
//		}
//		
//		res.remove(root.data);		// Removing last element.
//		return false;
//	}
	
	public static Node lowestCommonAncestor(Node root, Node p, Node q) {
		if(root == null || root == p || root == q) return root;
		
		Node left = lowestCommonAncestor(root.left, p, q);
		Node right = lowestCommonAncestor(root.right, p, q);
		
		if(left == null) return right;
		else if(right == null) return left;
		else return root;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// 1 extra parameter.
	
//	public static LinkedList<Integer> rootToNodePath(Node root, int b) {
//		LinkedList<Integer> res = new LinkedList<>();
//		boolean isNodeFounded[] = {false};
//		solve(root, b, res, isNodeFounded);
//		return res;
//		
//	}
//	
//	public static void solve(Node root, int b, LinkedList<Integer> res, boolean isNodeFounded[]) {
//		if(root == null) return;
//		
//		solve(root.left, b, res, isNodeFounded);
//		if(!isNodeFounded[0]) solve(root.right, b, res, isNodeFounded);
//		if(root.data == b || isNodeFounded[0]) {
//			res.add(0, root.data);
//			isNodeFounded[0] = true;
//		}
//	}
	
	public static ArrayList<Integer> rootToNodePath(Node root, int b) {
		ArrayList<Integer> res = new ArrayList<>();
		solve(root, b, res);
		return res;
	}
	
	public static boolean solve(Node root, int b, ArrayList<Integer> res) {
		if(root == null) return false;
		
		res.add(root.data);
		if(root.data == b) return true;
		
		if(solve(root.left, b, res) || solve(root.right, b, res)) {
			return true;
		}
		
		res.remove(res.size() - 1);		// Removing last element.
		return false;
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	public static boolean symmetricBT(Node root) {
		if(root == null) return true;
		
		return isSymmetric(root.left, root.right);
	}
	
	public static boolean isSymmetric(Node root1, Node root2) {
		if(root1 == null || root2 == null) return root1==root2;
		
		return root1.data == root2.data 
				&& isSymmetric(root1.left, root2.right) 
				&& isSymmetric(root1.right, root2.left);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> rightViewOfBT(Node root) {
		List<Integer> res = new ArrayList<Integer>();
		getRightView(root, res, 0);
		return res;
	}
	
	public static void getRightView(Node root, List<Integer> res, int level) {
		if(root == null) return;
		
		if(level == res.size()) res.add(root.data);
		getRightView(root.right, res, level+1);
		getRightView(root.left, res, level+1);
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	
	// Class required for Bottom view and Top view.
	static class Pair {
		Node root;
		int col;
		public Pair(Node _root, int _col) {
			root = _root;
			col = _col;		// Vertical
		}
	}
	
	public static ArrayList<Integer> bottonViewOfBT(Node root) {
		ArrayList<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.put(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		
		return res;
	}
	
	public static List<Integer> topViewOfBT(Node root) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.putIfAbsent(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	// Class required for Vertical Traversal.
	static class Tuple {
		Node root;
		int row;		// Level
		int col;		// Vertical
		public Tuple(Node _root, int _row, int _col) {
			root = _root;
			row = _row;
			col = _col;
		}
	}
	
	public static List<List<Integer>> verticalTraversal(Node root) {
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		// Vertical, Level
		TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();
		Queue<Tuple> q = new LinkedList<>();
		q.offer(new Tuple(root, 0, 0));
		
		while(!q.isEmpty()) {
			Tuple t = q.poll();
			Node n = t.root;
			int x = t.row;
			int y = t.col;
			
			map.putIfAbsent(y, new TreeMap<>());	// Adding Vertical if absent.
			map.get(y).putIfAbsent(x, new PriorityQueue<>());	// Adding Level if absent.
			
			map.get(y).get(x).offer(n.data);
			
			if(n.left != null) q.offer(new Tuple(n.left, x+1, y-1));
			if(n.right != null) q.offer(new Tuple(n.right, x+1, y+1));
		}
		
		// Traversing over "map" to add node.data to List.
		for(TreeMap<Integer, PriorityQueue<Integer>> ys : map.values()) {
			List<Integer> v = new ArrayList<>();
			for(PriorityQueue<Integer> nodes : ys.values()) {
				while(!nodes.isEmpty()) {
					v.add(nodes.poll());
				}
			}
			res.add(v);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	// Below 4 method is for boundary traversal.
	
	// I coded this whole on my own. Best thing is I did it using recursion.
//	public static ArrayList<Integer> boundaryTraversal(Node root) {
//		ArrayList<Integer> res = new ArrayList<Integer>();
//		if(root == null) return res;
//		
//		res.add(root.data);
//		
//		leftBoundary(root.left, res);
//		leafBoundary(root, res);
//		
//		int size = res.size();
//		rightBoundary(root.right, res, size);
//		
//		return res;
//	}
//	
//	public static void leftBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.left == null) {
//			res.add(root.data);
//			leftBoundary(root.right, res);
//		} else {
//			res.add(root.data);
//			leftBoundary(root.left, res);
//		}
//	}
//	
//	public static void rightBoundary(Node root, ArrayList<Integer> res, int size) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.right == null) {
//			res.add(size, root.data);
//			rightBoundary(root.left, res, size);
//		} else {
//			res.add(size, root.data);
//			rightBoundary(root.right, res, size);
//		}
//	}
//
//	public static void leafBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		
//		if(root.left == null && root.right == null) {
//			res.add(root.data);
//			return;
//		}
//		
//		leafBoundary(root.left, res);
//		leafBoundary(root.right, res);
//		
//	}
	
	// This solution is by RVA. It has more readability, clean and understandble.
    public static ArrayList <Integer> boundaryTraversal(Node root) {
	    ArrayList<Integer> ans = new ArrayList<Integer>(); 
	    ans.add(root.data);
	    
	    addLeftBoundary(root, ans); 
	    addLeaves(root, ans); 
	    addRightBoundary(root, ans); 
	    return ans;
	}
    
    public static Boolean isLeaf(Node root) {
        return (root.left == null) && (root.right == null);
    }
    
    public static void addLeftBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.left;
        while (cur != null) {
            if (isLeaf(cur) == false) res.add(cur.data);
            if (cur.left != null) cur = cur.left;
            else cur = cur.right;
        }
    }
    
    public static void addRightBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.right;
        ArrayList<Integer> tmp = new ArrayList<Integer>();
        
        while (cur != null) {
            if (isLeaf(cur) == false) tmp.add(cur.data);
            if (cur.right != null) cur = cur.right;
            else cur = cur.left;
        }

        for (int i = tmp.size()-1; i >= 0; --i) {
            res.add(tmp.get(i));
        }
    }
    
    public static void addLeaves(Node root, ArrayList<Integer> res) {
        if(root == null) return;
    	
    	if(isLeaf(root)) {
            res.add(root.data);
            return;
        }
        addLeaves(root.left, res);
        addLeaves(root.right, res);
    }
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) {
//			isIdentical[0] = false;
//			return;
//		}
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Solution by RVA.
	public static boolean isSameTree(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree(root1.left, root2.left) && isSameTree(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal. I did this on my own.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-06 15:09:45.817
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-06 15:09:45.817
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-06 15:09:47.845
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 				   / \
		 * 				  69  70
		 * 						\
		 * 						700
		 */
		
		Node root1 = new Node(1);

		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left = new Node(69);
		root1.left.right.right.right = new Node(70);
		root1.left.right.right.right.right = new Node(700);
		
		/**
		 * 					10
		 * 				  /    \
		 * 				 5	   20
		 * 				/ \    / \
		 * 			   3   8  18  25 
		 * 
		 * 
		 */
		
		Node root2 = new Node(10);
		
		root2.left = new Node(5);
		root2.left.right = new Node(8);
		root2.left.right.left = new Node(7);
		root2.left.left = new Node(3);
		
		root2.right = new Node(20);
		root2.right.left = new Node(18);
		root2.right.right = new Node(25);
		
		
		//System.out.println(balancedBinaryTree(root));

		//System.out.println(boundaryTraversal(root2));
		
		//System.out.println(topViewOfBT(root2));
		
		System.out.println(minimumTimeToBurnBT(root1, 4));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	public static int minimumTimeToBurnBT(Node root, int start) {
		HashMap<Node, Node> parent = new HashMap<>();
		Node target = markParent(root, parent);
		
		return burnTree(target, parent);
	}
	
	public static int burnTree(Node target, HashMap<N>)
	
	public static Node markParent(Node root, HashMap<Node, Node> parent) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> distanceK(Node root, Node target, int k ) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		// Child, Parent
		Map<Node, Node> parentTrack = new HashMap<>();
		markParents(root, parentTrack, target);
		
		Map<Node, Boolean> visited = new HashMap<>();
		Queue<Node> q = new LinkedList<>();
		
		q.offer(target);
		visited.put(target, true);
		int curLevel = 0;
		
		while(!q.isEmpty()) {
			int size = q.size();
			
			if(curLevel++ == k) break;
			
			for(int i = 0; i < size; ++i) {
				Node cur = q.poll();
				
				if(cur.left != null && visited.get(cur.left) == null) {
					q.offer(cur.left);
					visited.put(cur.left, true);
				}
				if(cur.right != null && visited.get(cur.right) == null) {
					q.offer(cur.right);
					visited.put(cur.right, true);
				}
				if(parentTrack.get(cur) != null && visited.get(parentTrack.get(cur)) == null) {
					q.offer(parentTrack.get(cur));
					visited.put(parentTrack.get(cur), true);
				}
			}
		}
		
		for(Node i : q) {
			res.add(i.data);
		}
		
		return res;
	}
	
	public static void markParents(Node root, Map<Node, Node> parentTrack, Node target) {
		Queue<Node> q = new LinkedList<>();
		q.offer(root);
		
		while(!q.isEmpty()) {
			Node cur = q.poll();
			
			if(cur.left != null) {
				parentTrack.put(cur.left, cur);
				q.offer(cur.left);
			}
			
			if(cur.right != null) {
				parentTrack.put(cur.right, cur);
				q.offer(cur.right);
			}
		}
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void childrenSumProperty(Node root) {
	// Feeling excited with other 69 PBC because I coded this on my own.
		if(root == null) return;
		
		int rootData = root.data;
		int leftChildData = 0;
		if(root.left != null) leftChildData = root.left.data;
		int rightChildData = 0;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		} else if(leftChildData + rightChildData < rootData) {
			if(root.left != null) root.left.data = root.data;
			if(root.right != null) root.right.data = root.data;
		}
		
		childrenSumProperty(root.left);
		childrenSumProperty(root.right);
		
		if(root.left != null) leftChildData = root.left.data;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		}
	}
	
	public static void maxWidthOfBT(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// brute force approach.
	
//	public static int lowestCommonAncestor(Node root, Node p, Node q) {
//		
//		Set<Integer> pPath = new LinkedHashSet<Integer>();
//		Set<Integer> qPath = new HashSet<Integer>();
//		getPath(root, p.data, pPath);
//		getPath(root, q.data, qPath);
//		
//		System.out.println(pPath.toString());
//		
//		int res = 0;
//		
//		for(Integer i : pPath) {
//			if(qPath.contains(i)) res = i;
//			else break;
//		}
//		
//		return res;
//	}
//	
//	public static boolean getPath(Node root, int n, Set<Integer> res) {
//		if(root == null) return false;
//		
//		res.add(root.data);
//		if(root.data == n) return true;
//		
//		if(getPath(root.left, n, res) || getPath(root.right, n, res)) {
//			return true;
//		}
//		
//		res.remove(root.data);		// Removing last element.
//		return false;
//	}
	
	public static Node lowestCommonAncestor(Node root, Node p, Node q) {
		if(root == null || root == p || root == q) return root;
		
		Node left = lowestCommonAncestor(root.left, p, q);
		Node right = lowestCommonAncestor(root.right, p, q);
		
		if(left == null) return right;
		else if(right == null) return left;
		else return root;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// 1 extra parameter.
	
//	public static LinkedList<Integer> rootToNodePath(Node root, int b) {
//		LinkedList<Integer> res = new LinkedList<>();
//		boolean isNodeFounded[] = {false};
//		solve(root, b, res, isNodeFounded);
//		return res;
//		
//	}
//	
//	public static void solve(Node root, int b, LinkedList<Integer> res, boolean isNodeFounded[]) {
//		if(root == null) return;
//		
//		solve(root.left, b, res, isNodeFounded);
//		if(!isNodeFounded[0]) solve(root.right, b, res, isNodeFounded);
//		if(root.data == b || isNodeFounded[0]) {
//			res.add(0, root.data);
//			isNodeFounded[0] = true;
//		}
//	}
	
	public static ArrayList<Integer> rootToNodePath(Node root, int b) {
		ArrayList<Integer> res = new ArrayList<>();
		solve(root, b, res);
		return res;
	}
	
	public static boolean solve(Node root, int b, ArrayList<Integer> res) {
		if(root == null) return false;
		
		res.add(root.data);
		if(root.data == b) return true;
		
		if(solve(root.left, b, res) || solve(root.right, b, res)) {
			return true;
		}
		
		res.remove(res.size() - 1);		// Removing last element.
		return false;
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	public static boolean symmetricBT(Node root) {
		if(root == null) return true;
		
		return isSymmetric(root.left, root.right);
	}
	
	public static boolean isSymmetric(Node root1, Node root2) {
		if(root1 == null || root2 == null) return root1==root2;
		
		return root1.data == root2.data 
				&& isSymmetric(root1.left, root2.right) 
				&& isSymmetric(root1.right, root2.left);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> rightViewOfBT(Node root) {
		List<Integer> res = new ArrayList<Integer>();
		getRightView(root, res, 0);
		return res;
	}
	
	public static void getRightView(Node root, List<Integer> res, int level) {
		if(root == null) return;
		
		if(level == res.size()) res.add(root.data);
		getRightView(root.right, res, level+1);
		getRightView(root.left, res, level+1);
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	
	// Class required for Bottom view and Top view.
	static class Pair {
		Node root;
		int col;
		public Pair(Node _root, int _col) {
			root = _root;
			col = _col;		// Vertical
		}
	}
	
	public static ArrayList<Integer> bottonViewOfBT(Node root) {
		ArrayList<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.put(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		
		return res;
	}
	
	public static List<Integer> topViewOfBT(Node root) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.putIfAbsent(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	// Class required for Vertical Traversal.
	static class Tuple {
		Node root;
		int row;		// Level
		int col;		// Vertical
		public Tuple(Node _root, int _row, int _col) {
			root = _root;
			row = _row;
			col = _col;
		}
	}
	
	public static List<List<Integer>> verticalTraversal(Node root) {
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		// Vertical, Level
		TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();
		Queue<Tuple> q = new LinkedList<>();
		q.offer(new Tuple(root, 0, 0));
		
		while(!q.isEmpty()) {
			Tuple t = q.poll();
			Node n = t.root;
			int x = t.row;
			int y = t.col;
			
			map.putIfAbsent(y, new TreeMap<>());	// Adding Vertical if absent.
			map.get(y).putIfAbsent(x, new PriorityQueue<>());	// Adding Level if absent.
			
			map.get(y).get(x).offer(n.data);
			
			if(n.left != null) q.offer(new Tuple(n.left, x+1, y-1));
			if(n.right != null) q.offer(new Tuple(n.right, x+1, y+1));
		}
		
		// Traversing over "map" to add node.data to List.
		for(TreeMap<Integer, PriorityQueue<Integer>> ys : map.values()) {
			List<Integer> v = new ArrayList<>();
			for(PriorityQueue<Integer> nodes : ys.values()) {
				while(!nodes.isEmpty()) {
					v.add(nodes.poll());
				}
			}
			res.add(v);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	// Below 4 method is for boundary traversal.
	
	// I coded this whole on my own. Best thing is I did it using recursion.
//	public static ArrayList<Integer> boundaryTraversal(Node root) {
//		ArrayList<Integer> res = new ArrayList<Integer>();
//		if(root == null) return res;
//		
//		res.add(root.data);
//		
//		leftBoundary(root.left, res);
//		leafBoundary(root, res);
//		
//		int size = res.size();
//		rightBoundary(root.right, res, size);
//		
//		return res;
//	}
//	
//	public static void leftBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.left == null) {
//			res.add(root.data);
//			leftBoundary(root.right, res);
//		} else {
//			res.add(root.data);
//			leftBoundary(root.left, res);
//		}
//	}
//	
//	public static void rightBoundary(Node root, ArrayList<Integer> res, int size) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.right == null) {
//			res.add(size, root.data);
//			rightBoundary(root.left, res, size);
//		} else {
//			res.add(size, root.data);
//			rightBoundary(root.right, res, size);
//		}
//	}
//
//	public static void leafBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		
//		if(root.left == null && root.right == null) {
//			res.add(root.data);
//			return;
//		}
//		
//		leafBoundary(root.left, res);
//		leafBoundary(root.right, res);
//		
//	}
	
	// This solution is by RVA. It has more readability, clean and understandble.
    public static ArrayList <Integer> boundaryTraversal(Node root) {
	    ArrayList<Integer> ans = new ArrayList<Integer>(); 
	    ans.add(root.data);
	    
	    addLeftBoundary(root, ans); 
	    addLeaves(root, ans); 
	    addRightBoundary(root, ans); 
	    return ans;
	}
    
    public static Boolean isLeaf(Node root) {
        return (root.left == null) && (root.right == null);
    }
    
    public static void addLeftBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.left;
        while (cur != null) {
            if (isLeaf(cur) == false) res.add(cur.data);
            if (cur.left != null) cur = cur.left;
            else cur = cur.right;
        }
    }
    
    public static void addRightBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.right;
        ArrayList<Integer> tmp = new ArrayList<Integer>();
        
        while (cur != null) {
            if (isLeaf(cur) == false) tmp.add(cur.data);
            if (cur.right != null) cur = cur.right;
            else cur = cur.left;
        }

        for (int i = tmp.size()-1; i >= 0; --i) {
            res.add(tmp.get(i));
        }
    }
    
    public static void addLeaves(Node root, ArrayList<Integer> res) {
        if(root == null) return;
    	
    	if(isLeaf(root)) {
            res.add(root.data);
            return;
        }
        addLeaves(root.left, res);
        addLeaves(root.right, res);
    }
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) {
//			isIdentical[0] = false;
//			return;
//		}
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Solution by RVA.
	public static boolean isSameTree(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree(root1.left, root2.left) && isSameTree(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal. I did this on my own.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-06 15:09:47.846
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-06 15:09:47.847
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-06 15:09:51.376
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package binaryTree;

import java.util.*;

public class BinaryTree<E> {
	
	
	
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {		
	/** @author Ayush
	 *	A Tree with each node having atmost 2 children is binary Tree.
	 *	Maximum number of nodes at level at level i is 2^i.
	 *	Maximum number of nodes in a tree with height h is 2^h-1.	
	 */

		// Node root = createTree();
		
		/**
		 * 					1
		 * 				 /	   \
		 * 				2	    3
		 * 			   / \	   / \	
		 * 			  4   5  100 200
		 * 			     / \
		 * 			    6   7
		 * 				   / \
		 * 				  69  70
		 * 						\
		 * 						700
		 */
		
		Node root1 = new Node(1);

		root1.left = new Node(2);
		root1.left.left = new Node(4);
		
		root1.right = new Node(3);
		root1.right.left = new Node(100);
		root1.right.right = new Node(200);
		
		root1.left.right = new Node(5);
		
		root1.left.right.left = new Node(6);
		root1.left.right.right = new Node(7);
		root1.left.right.right.left = new Node(69);
		root1.left.right.right.right = new Node(70);
		root1.left.right.right.right.right = new Node(700);
		
		/**
		 * 					10
		 * 				  /    \
		 * 				 5	   20
		 * 				/ \    / \
		 * 			   3   8  18  25 
		 * 
		 * 
		 */
		
		Node root2 = new Node(10);
		
		root2.left = new Node(5);
		root2.left.right = new Node(8);
		root2.left.right.left = new Node(7);
		root2.left.left = new Node(3);
		
		root2.right = new Node(20);
		root2.right.left = new Node(18);
		root2.right.right = new Node(25);
		
		
		//System.out.println(balancedBinaryTree(root));

		//System.out.println(boundaryTraversal(root2));
		
		//System.out.println(topViewOfBT(root2));
		
		System.out.println(minimumTimeToBurnBT(root1, 4));
		
	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	public static int minimumTimeToBurnBT(Node root, int start) {
		HashMap<Node, Node> parent = new HashMap<>();
		Node target = markParent(root, parent);
		
		return burnTree(target, parent);
	}
	
	public static int burnTree(Node target, HashMap<Node, Node>)
	
	public static Node markParent(Node root, HashMap<Node, Node> parent) {
		
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> distanceK(Node root, Node target, int k ) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		// Child, Parent
		Map<Node, Node> parentTrack = new HashMap<>();
		markParents(root, parentTrack, target);
		
		Map<Node, Boolean> visited = new HashMap<>();
		Queue<Node> q = new LinkedList<>();
		
		q.offer(target);
		visited.put(target, true);
		int curLevel = 0;
		
		while(!q.isEmpty()) {
			int size = q.size();
			
			if(curLevel++ == k) break;
			
			for(int i = 0; i < size; ++i) {
				Node cur = q.poll();
				
				if(cur.left != null && visited.get(cur.left) == null) {
					q.offer(cur.left);
					visited.put(cur.left, true);
				}
				if(cur.right != null && visited.get(cur.right) == null) {
					q.offer(cur.right);
					visited.put(cur.right, true);
				}
				if(parentTrack.get(cur) != null && visited.get(parentTrack.get(cur)) == null) {
					q.offer(parentTrack.get(cur));
					visited.put(parentTrack.get(cur), true);
				}
			}
		}
		
		for(Node i : q) {
			res.add(i.data);
		}
		
		return res;
	}
	
	public static void markParents(Node root, Map<Node, Node> parentTrack, Node target) {
		Queue<Node> q = new LinkedList<>();
		q.offer(root);
		
		while(!q.isEmpty()) {
			Node cur = q.poll();
			
			if(cur.left != null) {
				parentTrack.put(cur.left, cur);
				q.offer(cur.left);
			}
			
			if(cur.right != null) {
				parentTrack.put(cur.right, cur);
				q.offer(cur.right);
			}
		}
	}
	
	/* ------------------------------------------------------------------ */
	
	public static void childrenSumProperty(Node root) {
	// Feeling excited with other 69 PBC because I coded this on my own.
		if(root == null) return;
		
		int rootData = root.data;
		int leftChildData = 0;
		if(root.left != null) leftChildData = root.left.data;
		int rightChildData = 0;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		} else if(leftChildData + rightChildData < rootData) {
			if(root.left != null) root.left.data = root.data;
			if(root.right != null) root.right.data = root.data;
		}
		
		childrenSumProperty(root.left);
		childrenSumProperty(root.right);
		
		if(root.left != null) leftChildData = root.left.data;
		if(root.right != null) rightChildData = root.right.data;
		
		if(leftChildData + rightChildData > rootData) {
			root.data = leftChildData + rightChildData;
		}
	}
	
	public static void maxWidthOfBT(Node root) {
		
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// brute force approach.
	
//	public static int lowestCommonAncestor(Node root, Node p, Node q) {
//		
//		Set<Integer> pPath = new LinkedHashSet<Integer>();
//		Set<Integer> qPath = new HashSet<Integer>();
//		getPath(root, p.data, pPath);
//		getPath(root, q.data, qPath);
//		
//		System.out.println(pPath.toString());
//		
//		int res = 0;
//		
//		for(Integer i : pPath) {
//			if(qPath.contains(i)) res = i;
//			else break;
//		}
//		
//		return res;
//	}
//	
//	public static boolean getPath(Node root, int n, Set<Integer> res) {
//		if(root == null) return false;
//		
//		res.add(root.data);
//		if(root.data == n) return true;
//		
//		if(getPath(root.left, n, res) || getPath(root.right, n, res)) {
//			return true;
//		}
//		
//		res.remove(root.data);		// Removing last element.
//		return false;
//	}
	
	public static Node lowestCommonAncestor(Node root, Node p, Node q) {
		if(root == null || root == p || root == q) return root;
		
		Node left = lowestCommonAncestor(root.left, p, q);
		Node right = lowestCommonAncestor(root.right, p, q);
		
		if(left == null) return right;
		else if(right == null) return left;
		else return root;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process. Only problem is it is using
	// 1 extra parameter.
	
//	public static LinkedList<Integer> rootToNodePath(Node root, int b) {
//		LinkedList<Integer> res = new LinkedList<>();
//		boolean isNodeFounded[] = {false};
//		solve(root, b, res, isNodeFounded);
//		return res;
//		
//	}
//	
//	public static void solve(Node root, int b, LinkedList<Integer> res, boolean isNodeFounded[]) {
//		if(root == null) return;
//		
//		solve(root.left, b, res, isNodeFounded);
//		if(!isNodeFounded[0]) solve(root.right, b, res, isNodeFounded);
//		if(root.data == b || isNodeFounded[0]) {
//			res.add(0, root.data);
//			isNodeFounded[0] = true;
//		}
//	}
	
	public static ArrayList<Integer> rootToNodePath(Node root, int b) {
		ArrayList<Integer> res = new ArrayList<>();
		solve(root, b, res);
		return res;
	}
	
	public static boolean solve(Node root, int b, ArrayList<Integer> res) {
		if(root == null) return false;
		
		res.add(root.data);
		if(root.data == b) return true;
		
		if(solve(root.left, b, res) || solve(root.right, b, res)) {
			return true;
		}
		
		res.remove(res.size() - 1);		// Removing last element.
		return false;
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	public static boolean symmetricBT(Node root) {
		if(root == null) return true;
		
		return isSymmetric(root.left, root.right);
	}
	
	public static boolean isSymmetric(Node root1, Node root2) {
		if(root1 == null || root2 == null) return root1==root2;
		
		return root1.data == root2.data 
				&& isSymmetric(root1.left, root2.right) 
				&& isSymmetric(root1.right, root2.left);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> rightViewOfBT(Node root) {
		List<Integer> res = new ArrayList<Integer>();
		getRightView(root, res, 0);
		return res;
	}
	
	public static void getRightView(Node root, List<Integer> res, int level) {
		if(root == null) return;
		
		if(level == res.size()) res.add(root.data);
		getRightView(root.right, res, level+1);
		getRightView(root.left, res, level+1);
	}
	
	/* ------------------------------------------------------------------ */
	// This is completly written by my own thinking process.
	
	// Class required for Bottom view and Top view.
	static class Pair {
		Node root;
		int col;
		public Pair(Node _root, int _col) {
			root = _root;
			col = _col;		// Vertical
		}
	}
	
	public static ArrayList<Integer> bottonViewOfBT(Node root) {
		ArrayList<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.put(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		
		return res;
	}
	
	public static List<Integer> topViewOfBT(Node root) {
		List<Integer> res = new ArrayList<>();
		if(root == null) return res;
		
		TreeMap<Integer, Integer> map = new TreeMap<>();
		Queue<Pair> q = new LinkedList<>();
		q.offer(new Pair(root, 0));
		
		while(!q.isEmpty()) {
			Pair p = q.poll();
			Node n = p.root;
			int col = p.col;
			
			map.putIfAbsent(col, n.data);
			
			if(n.left != null) q.offer(new Pair(n.left, col-1));
			if(n.right != null) q.offer(new Pair(n.right, col+1));
		}
		
		for(Integer i : map.values()) {
			res.add(i);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	
	// Class required for Vertical Traversal.
	static class Tuple {
		Node root;
		int row;		// Level
		int col;		// Vertical
		public Tuple(Node _root, int _row, int _col) {
			root = _root;
			row = _row;
			col = _col;
		}
	}
	
	public static List<List<Integer>> verticalTraversal(Node root) {
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		// Vertical, Level
		TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();
		Queue<Tuple> q = new LinkedList<>();
		q.offer(new Tuple(root, 0, 0));
		
		while(!q.isEmpty()) {
			Tuple t = q.poll();
			Node n = t.root;
			int x = t.row;
			int y = t.col;
			
			map.putIfAbsent(y, new TreeMap<>());	// Adding Vertical if absent.
			map.get(y).putIfAbsent(x, new PriorityQueue<>());	// Adding Level if absent.
			
			map.get(y).get(x).offer(n.data);
			
			if(n.left != null) q.offer(new Tuple(n.left, x+1, y-1));
			if(n.right != null) q.offer(new Tuple(n.right, x+1, y+1));
		}
		
		// Traversing over "map" to add node.data to List.
		for(TreeMap<Integer, PriorityQueue<Integer>> ys : map.values()) {
			List<Integer> v = new ArrayList<>();
			for(PriorityQueue<Integer> nodes : ys.values()) {
				while(!nodes.isEmpty()) {
					v.add(nodes.poll());
				}
			}
			res.add(v);
		}
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	// Below 4 method is for boundary traversal.
	
	// I coded this whole on my own. Best thing is I did it using recursion.
//	public static ArrayList<Integer> boundaryTraversal(Node root) {
//		ArrayList<Integer> res = new ArrayList<Integer>();
//		if(root == null) return res;
//		
//		res.add(root.data);
//		
//		leftBoundary(root.left, res);
//		leafBoundary(root, res);
//		
//		int size = res.size();
//		rightBoundary(root.right, res, size);
//		
//		return res;
//	}
//	
//	public static void leftBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.left == null) {
//			res.add(root.data);
//			leftBoundary(root.right, res);
//		} else {
//			res.add(root.data);
//			leftBoundary(root.left, res);
//		}
//	}
//	
//	public static void rightBoundary(Node root, ArrayList<Integer> res, int size) {
//		
//		if(root == null) return;
//		if(root.left == null && root.right == null) return;
//		if(root.right == null) {
//			res.add(size, root.data);
//			rightBoundary(root.left, res, size);
//		} else {
//			res.add(size, root.data);
//			rightBoundary(root.right, res, size);
//		}
//	}
//
//	public static void leafBoundary(Node root, ArrayList<Integer> res) {
//		
//		if(root == null) return;
//		
//		if(root.left == null && root.right == null) {
//			res.add(root.data);
//			return;
//		}
//		
//		leafBoundary(root.left, res);
//		leafBoundary(root.right, res);
//		
//	}
	
	// This solution is by RVA. It has more readability, clean and understandble.
    public static ArrayList <Integer> boundaryTraversal(Node root) {
	    ArrayList<Integer> ans = new ArrayList<Integer>(); 
	    ans.add(root.data);
	    
	    addLeftBoundary(root, ans); 
	    addLeaves(root, ans); 
	    addRightBoundary(root, ans); 
	    return ans;
	}
    
    public static Boolean isLeaf(Node root) {
        return (root.left == null) && (root.right == null);
    }
    
    public static void addLeftBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.left;
        while (cur != null) {
            if (isLeaf(cur) == false) res.add(cur.data);
            if (cur.left != null) cur = cur.left;
            else cur = cur.right;
        }
    }
    
    public static void addRightBoundary(Node root, ArrayList<Integer> res) {
        Node cur = root.right;
        ArrayList<Integer> tmp = new ArrayList<Integer>();
        
        while (cur != null) {
            if (isLeaf(cur) == false) tmp.add(cur.data);
            if (cur.right != null) cur = cur.right;
            else cur = cur.left;
        }

        for (int i = tmp.size()-1; i >= 0; --i) {
            res.add(tmp.get(i));
        }
    }
    
    public static void addLeaves(Node root, ArrayList<Integer> res) {
        if(root == null) return;
    	
    	if(isLeaf(root)) {
            res.add(root.data);
            return;
        }
        addLeaves(root.left, res);
        addLeaves(root.right, res);
    }
	
	/* ------------------------------------------------------------------ */
	
	public static List<List<Integer>> zigZagTraversal(Node root) {
	// I did both solution 1 and 2 on my own.
		
		// Solution 1 ---------------------------
//		List<List<Integer>> res = new ArrayList<List<Integer>>();
//		ArrayDeque<Node> ad = new ArrayDeque<Node>();
//		
//		if(root == null) return res;
//		ad.offerFirst(root);
//		
//		boolean flip = false;
//		
//		while(!ad.isEmpty()) {
//			ArrayList<Integer> zigZag = new ArrayList<Integer>();
//			int size = ad.size();
//			
//			for(int i = 0; i < size; ++i) {
//				if(flip == true) {
//					if(ad.peekLast().right != null) ad.offerFirst(ad.peekLast().right);
//					if(ad.peekLast().left != null) ad.offerFirst(ad.peekLast().left);
//				} else if(flip == false){
//					if(ad.peekFirst().left != null) ad.offerLast(ad.peekFirst().left);
//					if(ad.peekFirst().right != null) ad.offerLast(ad.peekFirst().right);
//				}
//				
//				if(flip) zigZag.add(ad.pollLast().data);
//				else zigZag.add(ad.pollFirst().data);
//			}
//			flip = !flip;
//			res.add(zigZag);
//		}
//		return res;
		
		// Solution 2 ---------------------------
		List<List<Integer>> res = new ArrayList<>();
		
		if(root == null) return res;
		
		boolean flip = false;
		Queue<Node> q = new LinkedList<Node>();
		
		q.add(root);
		while(!q.isEmpty()) {
			ArrayList<Integer> zigZag = new ArrayList<Integer>();
			int size = q.size();
			
			for(int i = 0; i < size; ++i) {
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				if(flip) zigZag.add(0, q.poll().data);
				else zigZag.add(q.poll().data);
			}
			flip = !flip;
			res.add(zigZag);
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	
	// This is completly written by own my thinking process having same time complexity than
	// the below ones but taking more memory and very long code in comparison.
	
//	public static boolean isSameTree(Node root1, Node root2) {
//		
//		boolean res[] = new boolean[1];
//		res[0] = true;
//		identicalTrees(root1, root2, res);
//		
//		return res[0];
//	}
//	
//	public static void identicalTrees(Node root1, Node root2, boolean isIdentical[]) {
//		
//		if(root1 == null && root2 == null) return;
//		if(root1 == null || root2 == null) {
//			isIdentical[0] = false;
//			return;
//		}
//	
//		if(root1.data != root2.data) {
//			isIdentical[0] = false;
//			return;
//		}
//		identicalTrees(root1.left, root2.left, isIdentical);
//		identicalTrees(root1.right, root2.right, isIdentical);
//		
//	}
	
	// Solution by RVA.
	public static boolean isSameTree(Node root1, Node root2) {
		if(root1 == null || root2 == null) {
			return root1==root2;
		}
		
		return (root1.data==root2.data) &&
				isSameTree(root1.left, root2.left) && isSameTree(root1.right, root2.right);
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int maxPathSum(Node root) {
		
		int maxSum[] = new int[1];
		maxSum[0] = Integer.MIN_VALUE;
		
		getPathSum(root, maxSum);
		
		return maxSum[0];
		
	}

	public static int getPathSum(Node root, int maxSum[]) {
		if(root == null) return 0;
		
		int maxL = Math.max(0, getPathSum(root.left, maxSum));
		int maxR = Math.max(0, getPathSum(root.right, maxSum));
		
		maxSum[0] = Math.max(maxSum[0], root.data + maxL + maxR);
		
		return root.data + maxL + maxR;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static int diameterOfAbinaryTree(Node root) {
		
		int diameter[] = new int[1];
		depth(root, diameter);
		
		return diameter[0];
	}
	
	public static int depth(Node root, int diameter[]) {
		if(root == null) return 0;
		
		int lh = depth(root.left, diameter);
		int rh = depth(root.right, diameter);
		
		diameter[0] = Math.max(diameter[0], lh+rh);
		
		return Math.max(lh, rh) + 1;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static boolean balancedBinaryTree(Node root) {
	// If at any level, |(lh-rh > 1)| then tree is not balanced.

		int height = height(root);
		
		if(height == -1) return false;
		return true;
	}
	// This function is a part of method "balancedBinaryTree".
	public static int height(Node root) {
		
		if(root == null) return 0;
		
		int lh = height(root.left);
		if(lh == -1) return -1;
		int rh = height(root.right);
		if(rh == -1) return -1;
		
		if(Math.abs(rh-lh) > 1) return -1;
		
		return 1+Math.max(lh, rh);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// Using recursion.
	public static int heightOfABinaryTree1(Node root) {
		
		if(root == null) return 0;
		
		int left = heightOfABinaryTree1(root.left);
		int right = heightOfABinaryTree1(root.right);
		
		return 1 + Math.max(left, right);
		
	}
	
	// Using level order traversal. I did this on my own.
	public static int heightOfABinaryTree2(Node root) {
		
		int height = 0;
		if(root == null) return height;
		
		Queue<Node> q = new LinkedList<Node>();
		
		q.offer(root);
		while(!q.isEmpty()) {
			
			int level = q.size();
			for(int i = 0; i < level; ++i) {
				
				if(q.peek().left != null) q.offer(q.peek().left);
				if(q.peek().right != null) q.offer(q.peek().right);
				
				q.poll();
			}
			++height;
		}
		return height;
	}
	
	/* ------------------------------------------------------------------ */
	
	public static List<Integer> iterativePostorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		Stack<Node> s = new Stack<Node>();
		Stack<Node> r = new Stack<Node>();
		
		if(root == null) return result;
		
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			r.push(root);
			
			if(root.left != null) s.push(root.left);
			if(root.right != null) s.push(root.right);
			
		}
		
		while(!r.isEmpty()) {
			result.add(r.pop().data);
		}
		
		return result;
	}
	
	public static List<Integer> iterativePreorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		s.push(root);
		
		while(!s.isEmpty()) {
			
			root = s.pop();
			
			if(root.right != null) s.push(root.right);
			if(root.left != null) s.push(root.left);
			
			result.add(root.data);
		}
		return result;
	}
	
	public static List<Integer> iterativeInorderTraversal(Node root) {
		
		List<Integer> result = new ArrayList<Integer>();
		
		if(root == null) return result;
		
		Stack<Node> s = new Stack<Node>();
		
		Node temp = root;
		while(true) {
			
			if(temp != null) {
				s.push(temp);
				temp = temp.left;
			} else {
				if(s.empty()) break;
				
				temp = s.pop();
				result.add(temp.data);
				temp = temp.right;
			}
		}
		return result;
	}
	
	
	public static List<List<Integer>> levelOrderTraversal(Node root) {
		
		Queue<Node> queue = new LinkedList<Node>();
		List<List<Integer>> wrapList = new ArrayList<List<Integer>>();
		
		if(root == null) return wrapList;
		
		queue.offer(root);
		while(!queue.isEmpty()) {
			List<Integer> subList = new ArrayList<Integer>();
			int levelNum = queue.size();
			for(int i = 0; i < levelNum; ++i) {
				if(queue.peek().left != null) queue.offer(queue.peek().left);
				if(queue.peek().right != null) queue.offer(queue.peek().right);
				subList.add(queue.poll().data);
			}
			
			wrapList.add(subList);
		}
		return wrapList;
	}
		
	public static void inOrder(Node root) {
		if(root != null) {
			inOrder(root.left);
			System.out.println(root.data);
			inOrder(root.right);
		}
	}
	
	public static void preOrder(Node root) {
		if(root != null) {
			System.out.println(root.data);
			preOrder(root.left);
			preOrder(root.right);
		}
	}
	
	public static void postOrder(Node root) {
		if(root != null) {
			postOrder(root.left);
			postOrder(root.right);
			System.out.println(root.data);
		}
	}
	
	// ------------------------------------------------------------------
	
	public static Node createTree() {		
		Node root = null;
		System.out.println("Enter data: ");
		int data = sc.nextInt();
		
		if(data == -1) return null;		
		root = new Node(data);
		
		System.out.println("Enter left for: " +data);
		root.left = createTree();
		
		System.out.println("Enter right for: " +data);
		root.right = createTree();
		
		return root;
	}
	
}


// Node class for Binary Tree
class Node {
	Node left, right;
	int data;
	
	public Node(int data) {
		this.data = data;
	}
}


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-06 15:09:51.376
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-06 15:09:51.377
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2021-12-07 10:46:17.571 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-07 10:46:22.591
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-07 10:46:22.591
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-07 10:46:26.697
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-07 16:00:57.014 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-07 16:01:00.717
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-07 16:01:00.717
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-07 16:01:04.783
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-07 19:28:42.588 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-07 19:28:49.998
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-07 19:28:49.998
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-07 19:28:55.260
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-08 12:51:39.376 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-08 12:51:43.294
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-08 12:51:43.294
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-08 12:51:47.198
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-09 10:15:19.931 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-09 10:15:23.942
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-09 10:15:23.942
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70c31b17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-09 10:15:28.557
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-09 17:26:12.943 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-09 17:26:16.974
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-09 17:26:16.974
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@17befef0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5072e638,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-09 17:26:21.120
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-09 22:34:48.521 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-09 22:34:52.498
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-09 22:34:52.498
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-09 22:34:57.204
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-10 12:03:27.453 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-10 12:03:32.224
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-10 12:03:32.224
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-10 12:03:36.723
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-10 20:37:32.422 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-10 20:37:38.869
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-10 20:37:38.869
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-10 20:37:43.964
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-11 11:36:27.468 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-11 11:36:31.291
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-11 11:36:31.291
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-11 11:36:35.437
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-12 13:01:01.483 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-12 13:01:05.389
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-12 13:01:05.389
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-12 13:01:09.305
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-13 11:01:31.445 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-13 11:01:35.284
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-13 11:01:35.284
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-13 11:01:39.593
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-13 18:45:46.226 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-13 18:45:51.149
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-13 18:45:51.149
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@431babe6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@17befef0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-13 18:45:56.206
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-16 15:54:21.147 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-16 15:54:25.115
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-16 15:54:25.115
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-16 15:54:29.223
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-18 11:38:16.727 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-18 11:38:20.657
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-18 11:38:20.657
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-18 11:38:24.839
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-18 12:12:22.431 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-18 12:12:25.717
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-18 12:12:25.717
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-18 12:12:28.883
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-12-18 18:43:41.117
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package linkedList;

public class LS_LinkedList_Problems {

	public static void main(String[] args) {
		
		Node<Integer> ll1 = new Node<>(1);
		ll1.next = new Node<>(2);
		ll1.next.next = new Node<>(3);
		ll1.next.next.next = new Node<>(4);
		ll1.next.next.next.next = new Node<>(5);
		ll1.next.next.next.next.next = new Node<>(6);
		
		System.out.println(reverse(ll1));
		
	//	printList(reverse(ll1));
	}
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */

	public static Node<Integer> c()
	
	public static Node<Integer> reverse(Node<Integer> head) {
		Node<Integer> result = null;
		revLL(head, result);
		System.out.println(result);
		return result;
	}
	
	public static void revLL(Node<Integer> head, Node<Integer> result) {
		if(head == null) return;
		revLL(head.next, result);
		add(head.data, result);
	}
	
	public static void add(int data, Node<Integer> result) {
		Node<Integer> toAdd = new Node<>(data);
		if(result == null) {
			result = toAdd;
			System.out.println(result.data);
			return;
		}

		Node<Integer> temp = result;
		
		while(temp.next != null) {
			temp = temp.next;
		}
		
	//	System.out.println("hi");
		
		temp.next = toAdd;
	}
	
	
	
	/* ------------------------------------------------------------------ */
	public static int getDecimalValue(Node<Integer> head) {
		int size = 0;
		Node<Integer> temp = head;
		while(temp.next != null) {
			temp = temp.next;
			++size;
		}
		
		int res = 0;
		
		temp = head;
		while(temp != null) {
			res += temp.data == 0 ? 0 : Math.pow(2, size);
			--size;
			temp = temp.next;
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	public static Node<Integer> middleOfLL(Node<Integer> head) {

		// My solution, uses to iteration.
//		int size = 0;
//		Node<Integer> temp = head;
//		while(temp != null) {
//			temp = temp.next;
//			++size;
//		}
//		
//		int mid = size/2 + 1;
//		
//		temp = head;
//		while(mid > 0) {
//			temp = temp.next;
//			--mid;
//		}
//		return temp;
		
		// Someone's solution from leetcode using 1 iteration. Very clean and short.
		Node<Integer> slow = head;
		Node<Integer> fast = head;
		
		while(fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		
		return slow;
	}
	
	public static void printList(Node<Integer> head) {
		Node<Integer> temp = head;
		while(temp != null) {			
			System.out.println(temp.data);
			temp = temp.next;
		}
	}
	
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-18 18:43:41.122
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-18 18:43:41.123
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-18 18:44:16.286
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package linkedList;

public class LS_LinkedList_Problems {

	public static void main(String[] args) {
		
		Node<Integer> ll1 = new Node<>(1);
		ll1.next = new Node<>(2);
		ll1.next.next = new Node<>(3);
		ll1.next.next.next = new Node<>(4);
		ll1.next.next.next.next = new Node<>(5);
		ll1.next.next.next.next.next = new Node<>(6);
		
		System.out.println(reverse(ll1));
		
	//	printList(reverse(ll1));
	}
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */
	/* ------------------------------------------------------------------ */

	public static Node<Integer> c() {
		Node<Integer> n = new Node(10);
		return n;
	}
	
	public static void a()
	
	public static Node<Integer> reverse(Node<Integer> head) {
		Node<Integer> result = null;
		revLL(head, result);
		System.out.println(result);
		return result;
	}
	
	public static void revLL(Node<Integer> head, Node<Integer> result) {
		if(head == null) return;
		revLL(head.next, result);
		add(head.data, result);
	}
	
	public static void add(int data, Node<Integer> result) {
		Node<Integer> toAdd = new Node<>(data);
		if(result == null) {
			result = toAdd;
			System.out.println(result.data);
			return;
		}

		Node<Integer> temp = result;
		
		while(temp.next != null) {
			temp = temp.next;
		}
		
	//	System.out.println("hi");
		
		temp.next = toAdd;
	}
	
	
	
	/* ------------------------------------------------------------------ */
	public static int getDecimalValue(Node<Integer> head) {
		int size = 0;
		Node<Integer> temp = head;
		while(temp.next != null) {
			temp = temp.next;
			++size;
		}
		
		int res = 0;
		
		temp = head;
		while(temp != null) {
			res += temp.data == 0 ? 0 : Math.pow(2, size);
			--size;
			temp = temp.next;
		}
		
		return res;
	}
	
	/* ------------------------------------------------------------------ */
	public static Node<Integer> middleOfLL(Node<Integer> head) {

		// My solution, uses to iteration.
//		int size = 0;
//		Node<Integer> temp = head;
//		while(temp != null) {
//			temp = temp.next;
//			++size;
//		}
//		
//		int mid = size/2 + 1;
//		
//		temp = head;
//		while(mid > 0) {
//			temp = temp.next;
//			--mid;
//		}
//		return temp;
		
		// Someone's solution from leetcode using 1 iteration. Very clean and short.
		Node<Integer> slow = head;
		Node<Integer> fast = head;
		
		while(fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		
		return slow;
	}
	
	public static void printList(Node<Integer> head) {
		Node<Integer> temp = head;
		while(temp != null) {			
			System.out.println(temp.data);
			temp = temp.next;
		}
	}
	
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-18 18:44:16.288
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-18 18:44:16.288
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2021-12-21 09:41:25.409 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-21 09:41:29.440
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-21 09:41:29.440
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-21 09:41:33.834
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-22 18:22:25.665 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-22 18:22:30.173
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-22 18:22:30.173
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-22 18:22:35.299
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-23 20:16:45.659 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-23 20:16:50.533
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-23 20:16:50.533
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-23 20:16:55.459
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-24 18:20:33.623 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-24 18:20:38.924
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-24 18:20:38.924
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-24 18:20:43.147
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-25 19:55:21.349 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-25 19:55:25.237
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-25 19:55:25.237
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-25 19:55:29.347
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-25 21:31:32.327 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-25 21:31:36.552
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-25 21:31:36.552
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-25 21:31:41.534
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-25 21:45:10.769 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-25 21:45:14.101
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-25 21:45:14.101
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-25 21:45:17.560
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-26 09:48:03.150 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-26 09:48:07.466
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-26 09:48:07.466
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-26 09:48:11.844
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-26 12:20:17.705 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-26 12:20:20.840
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-26 12:20:20.841
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-26 12:20:24.114
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.jobs 4 2 2021-12-26 12:20:29.320
!MESSAGE An internal error occurred during: "Deferred Early Start".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.equinox.log.ExtendedLogReaderService.addLogListener(org.osgi.service.log.LogListener, org.eclipse.equinox.log.LogFilter)" because "logReader" is null
	at org.eclipse.core.internal.runtime.InternalPlatform.lambda$11(InternalPlatform.java:363)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
	at org.eclipse.core.internal.runtime.InternalPlatform.getLog(InternalPlatform.java:358)
	at org.eclipse.core.runtime.Plugin.getLog(Plugin.java:237)
	at org.eclipse.oomph.util.OomphPlugin.getLog(OomphPlugin.java:221)
	at org.eclipse.oomph.util.OomphPlugin.log(OomphPlugin.java:236)
	at org.eclipse.oomph.util.OomphPlugin.log(OomphPlugin.java:247)
	at org.eclipse.oomph.internal.ui.EarlyStart.run(EarlyStart.java:122)
	at org.eclipse.oomph.internal.ui.EarlyStart$1.run(EarlyStart.java:97)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-12-26 18:10:36.357 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-26 18:10:39.881
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-26 18:10:39.881
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3129299f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f73f0c7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-26 18:10:43.458
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-26 23:00:59.995 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-26 23:01:03.637
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-26 23:01:03.637
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-26 23:01:07.459
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-28 21:13:01.343 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-28 21:13:05.397
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-28 21:13:05.397
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8debe42,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70c31b17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-28 21:13:09.595
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-29 21:03:13.630 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-29 21:03:17.745
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-29 21:03:17.745
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-29 21:03:24.169
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-31 23:54:21.977 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-31 23:54:26.598
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-31 23:54:26.598
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8debe42,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70c31b17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-31 23:54:32.148
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.engine 4 4 2021-12-31 23:56:49.986
!MESSAGE An error occurred while collecting items to be installed
!SUBENTRY 1 org.eclipse.equinox.p2.engine 4 0 2021-12-31 23:56:49.986
!MESSAGE session context was:(profile=C__Users_Ayush_eclipse_java-2021-09_eclipse, phase=org.eclipse.equinox.internal.p2.engine.phases.Collect, operand=, action=).
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/technology/epp/packages/2021-12/202112021200/plugins/org.eclipse.epp.package.common_4.22.0.20211202-1200.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/technology/epp/packages/2021-12/202112021200/plugins/org.eclipse.epp.package.java_4.22.0.20211202-1200.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jdt.core_3.28.0.v20211117-1416.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jdt.core.manipulation_1.15.100.v20211115-1252.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jdt.debug_3.19.0.v20211112-1303.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jdt.debug.ui_3.12.500.v20211108-1545.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jdt.doc.user_3.15.1200.v20211124-1019.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jdt.launching_3.19.400.v20211011-0920.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jdt.ui_3.25.0.v20211115-1252.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jface_3.24.0.v20211110-1517.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jface.text_3.19.0.v20211026-2100.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jgit_6.0.0.202111291000-r.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jgit.archive_6.0.0.202111291000-r.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jgit.gpg.bc_6.0.0.202111291000-r.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jgit.http.apache_6.0.0.202111291000-r.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jgit.ssh.apache_6.0.0.202111291000-r.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jsch.ui_1.4.100.v20210917-1201.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.lsp4e_0.13.8.202111241523.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ltk.core.refactoring_3.12.100.v20210926-1112.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.archetype.common_1.18.1.20211011-2139.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.binaryproject_1.17.4.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.core_1.18.3.20211018-0804.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.core.ui_1.18.2.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.discovery_1.18.1.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.editor_1.18.2.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.editor.lemminx_1.18.3.20211116-0804.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.importer_1.17.3.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.jdt_1.18.3.20211112-0847.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.launching_1.17.4.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.logback.appender_1.17.2.20211002-0721.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.logback.configuration_1.16.3.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.maven.indexer_1.18.1.20211011-2139.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.maven.runtime_1.18.1.20211011-2139.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.maven.runtime.slf4j.simple_1.18.1.20211008-0657.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.model.edit_1.18.2.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.profiles.core_1.17.2.20211115-0834.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.profiles.ui_1.17.3.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.refactoring_1.17.3.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.sourcelookup_1.17.4.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.m2e.sourcelookup.ui_1.17.3.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext_3.0.41.20211110231712.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.986
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.ant_3.0.41.20211110231712.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.asciidoc_3.0.41.20211110231712.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.asciidoc.ui_3.0.41.202111102318.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.confluence_3.0.41.20211110231712.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.confluence.ui_3.0.41.202111102318.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.help.ui_3.0.41.202111102318.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.html_3.0.41.20211110231712.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.markdown_3.0.41.20211110231712.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.markdown.ui_3.0.41.202111102318.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.mediawiki_3.0.41.20211110231712.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.mediawiki.ui_3.0.41.202111102318.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.osgi_3.0.41.202111102318.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.textile_3.0.41.20211110231712.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.textile.ui_3.0.41.202111102318.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.tracwiki_3.0.41.20211110231712.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.tracwiki.ui_3.0.41.202111102318.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.twiki_3.0.41.20211110231712.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.twiki.ui_3.0.41.202111102318.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.mylyn.wikitext.ui_3.0.41.202111102318.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.osgi_3.17.100.v20211104-1730.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.platform_4.22.0.v20211124-1800.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.platform.doc.user_4.22.0.v20211123-1648.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.rcp_4.22.0.v20211124-1800.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.search_3.14.0.v20211108-0804.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.swt_3.118.0.v20211123-0851.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.swt.win32.win32.x86_64_3.118.0.v20211123-0851.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.team.core_3.9.200.v20211013-1022.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.tm.terminal.view.core_4.8.100.202110051557.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.tm.terminal.view.ui_4.10.100.202110140133.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.tm4e.core_0.4.3.202110141401.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.tm4e.registry_0.5.0.202111180858.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.tm4e.ui_0.5.0.202111180858.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui_3.200.0.v20211026-0701.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.browser_3.7.100.v20211105-1434.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.editors_3.14.300.v20210913-0815.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.forms_3.11.300.v20211022-1451.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.genericeditor_1.2.100.v20211021-1148.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.ide_3.18.400.v20211026-0701.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.ide.application_1.4.200.v20211026-0701.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.intro_3.6.400.v20211015-1317.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.navigator_3.10.200.v20211009-1706.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.navigator.resources_3.8.300.v20210914-2004.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.themes_1.2.1600.v20211001-1357.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.views.log_1.3.100.v20210927-1100.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.workbench_3.124.0.v20211116-0651.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.ui.workbench.texteditor_3.16.300.v20211119-1032.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.urischeme_1.2.100.v20211001-1648.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.wildwebdeveloper.xml_0.13.1.202111081705.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.jsoup_1.14.3.v20211012-1727.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit_4.13.2.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit.jupiter.api_5.8.1.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit.jupiter.engine_5.8.1.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit.jupiter.migrationsupport_5.8.1.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit.jupiter.params_5.8.1.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit.platform.commons_1.8.1.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit.platform.engine_1.8.1.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit.platform.launcher_1.8.1.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit.platform.runner_1.8.1.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit.platform.suite.api_1.8.1.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit.vintage.engine_5.8.1.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.opentest4j_1.2.0.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/technology/epp/packages/2021-12/202112021200/binary/epp.package.java.executable.win32.win32.x86_64_4.22.0.20211202-1200.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.debug.ui.launchview_1.0.2.v20211115-1052.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.987
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.e4.rcp_4.22.0.v20211123-0851.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.ecf.core.feature_1.6.1.v20211005-1944.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.ecf.filetransfer.httpclient45.feature_1.1.0.v20211008-2034.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.egit_6.0.0.202111291000-r.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.emf.common_2.24.0.v20210924-1718.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.emf.ecore_2.26.0.v20210924-1718.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.epp.mpc_1.9.2.v20210826-0851.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/technology/epp/packages/2021-12/202112021200/features/org.eclipse.epp.package.common.feature_4.22.0.20211202-1200.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/technology/epp/packages/2021-12/202112021200/features/org.eclipse.epp.package.java.feature_4.22.0.20211202-1200.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.equinox.p2.core.feature_1.6.1200.v20211104-1616.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.equinox.p2.extras.feature_1.4.1400.v20211104-1616.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.equinox.p2.rcp.feature_1.4.1400.v20211104-1616.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.equinox.p2.user.ui_2.4.1400.v20211104-1616.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.help_2.3.800.v20211124-1800.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.jdt_3.18.1000.v20211124-1800.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.jgit_6.0.0.202111291000-r.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.jgit.gpg.bc_6.0.0.202111291000-r.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.jgit.http.apache_6.0.0.202111291000-r.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.eclipse.jgit.ssh.apache.agent_6.0.0.202111291000-r.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.jgit.ssh.apache_6.0.0.202111291000-r.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.m2e.feature_1.19.0.20211116-0804.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.m2e.lemminx.feature_1.18.3.20211116-0804.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.m2e.logback.feature_1.17.2.20211002-1029.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.mylyn.wikitext.editors_feature_3.0.41.202111102318.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.platform_4.22.0.v20211124-1800.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/binary/org.eclipse.platform.ide.executable.win32.win32.x86_64_4.22.0.I20211124-1800.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/binary/org.eclipse.platform_root_4.22.0.v20211124-1800.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.rcp_4.22.0.v20211124-1800.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/binary/org.eclipse.rcp_root_4.22.0.v20211124-1800.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.tips.feature_0.2.1600.v20211106-0839.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.tm.terminal.connector.local.feature_10.5.0.202109270023.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.tm.terminal.connector.ssh.feature_10.5.0.202109270023.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.tm.terminal.connector.telnet.feature_10.5.0.202109270023.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.tm.terminal.control.feature_10.5.0.202109270023.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.tm.terminal.feature_10.5.0.202109270023.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.tm.terminal.view.feature_10.5.0.202110140133.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/features/org.eclipse.wildwebdeveloper.xml.feature_0.13.1.202111081705.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit.platform.suite.commons_1.8.1.v20211018-1956.jar.
!SUBENTRY 1 org.eclipse.equinox.p2.transport.ecf 4 1002 2021-12-31 23:56:49.988
!MESSAGE Error while reading from repository: https://download.eclipse.org/releases/2021-12/202112081000/plugins/org.junit.platform.suite.engine_1.8.1.v20211028-1957.jar.
!SESSION 2022-01-02 12:41:31.799 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-02 12:41:36.142
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-02 12:41:36.142
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-02 12:41:40.584
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-12 12:37:04.391 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-12 12:37:08.833
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-12 12:37:08.833
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ebbc06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-12 12:37:14.407
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-12 15:24:50.543 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-12 15:24:54.122
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-12 15:24:54.122
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-12 15:24:57.860
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-12 22:13:07.522 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-12 22:13:11.426
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-12 22:13:11.426
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70c31b17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-12 22:13:15.543
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-12 22:57:53.112 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-12 22:57:56.342
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-12 22:57:56.342
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3129299f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f73f0c7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-12 22:57:59.551
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-13 22:08:20.840 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-13 22:08:24.871
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-13 22:08:24.871
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-13 22:08:30.131
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-14 15:21:47.805 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-14 15:21:52.527
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-14 15:21:52.527
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-14 15:21:57.265
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-01-14 17:12:06.555
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

public class DynamicProgramming1 {

	public static void main(String[] args) {

	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	public static boolean canCross(int stones[]) {
		
//		int unitJumps[] = new int[stones.length];
//		unitJumps[0] = 1;
//
//		int index = 0;
//		
//		while(index >= 0 || index < stones.length-1) {
//			
//			if(unitJumps[index] == 0) {
//				--index;
//				continue;
//			}
//			
//			int unit = stones[index+1] - stones[index];
//			
//			if(unit == unitJumps[index]
//					|| unit == unitJumps[index]+1
//					|| unit == unitJumps[index]-1) {
//				unitJumps[++index] = unit;
//			} else {
//				unitJumps[index--] = 0;
//			}
//		}
		
	}
	
	public static boolean canCrossHelper(int index, int lastJump, int stones[]) {
		if(index >= stones.length -1) return true;
		
		for(int i = index+1; i < stones.length; ++i) {
			(stones[i] - stones[index]
		}
		
		boolean high = canCrossHelper();
		boolean equal = canCrossHelper();
		boolean less = canCrossHelper(index, lastJump, stones);
	}
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.3 Tabulation + SO
	public static int climbStairs3(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-14 17:12:06.559
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-14 17:12:06.560
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-14 17:12:06.572
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

public class DynamicProgramming1 {

	public static void main(String[] args) {

	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	public static boolean canCross(int stones[]) {
		
//		int unitJumps[] = new int[stones.length];
//		unitJumps[0] = 1;
//
//		int index = 0;
//		
//		while(index >= 0 || index < stones.length-1) {
//			
//			if(unitJumps[index] == 0) {
//				--index;
//				continue;
//			}
//			
//			int unit = stones[index+1] - stones[index];
//			
//			if(unit == unitJumps[index]
//					|| unit == unitJumps[index]+1
//					|| unit == unitJumps[index]-1) {
//				unitJumps[++index] = unit;
//			} else {
//				unitJumps[index--] = 0;
//			}
//		}
		
	}
	
	public static boolean canCrossHelper(int index, int lastJump, int stones[]) {
		if(index >= stones.length -1) return true;
		
		for(int i = index+1; i < stones.length; ++i) {
			(stones[i] - stones[index]
		}
		
		boolean high = canCrossHelper();
		boolean equal = canCrossHelper();
		boolean less = canCrossHelper(index, lastJump, stones);
	}
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.3 Tabulation + SO
	public static int climbStairs3(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-14 17:12:06.573
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-14 17:12:06.577
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-14 17:12:07.527
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

public class DynamicProgramming1 {

	public static void main(String[] args) {

	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	public static boolean canCross(int stones[]) {
		
//		int unitJumps[] = new int[stones.length];
//		unitJumps[0] = 1;
//
//		int index = 0;
//		
//		while(index >= 0 || index < stones.length-1) {
//			
//			if(unitJumps[index] == 0) {
//				--index;
//				continue;
//			}
//			
//			int unit = stones[index+1] - stones[index];
//			
//			if(unit == unitJumps[index]
//					|| unit == unitJumps[index]+1
//					|| unit == unitJumps[index]-1) {
//				unitJumps[++index] = unit;
//			} else {
//				unitJumps[index--] = 0;
//			}
//		}
		
	}
	
	public static boolean canCrossHelper(int index, int lastJump, int stones[]) {
		if(index >= stones.length -1) return true;
		
		for(int i = index+1; i < stones.length; ++i) {
			(stones[i] - stones[index]
		}
		
		boolean high = canCrossHelper();
		boolean equal = canCrossHelper();
		boolean less = canCrossHelper(index, lastJump, stones);
	}
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.3 Tabulation + SO
	public static int climbStairs3(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-14 17:12:07.530
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-14 17:12:07.531
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-14 17:12:08.670
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

public class DynamicProgramming1 {

	public static void main(String[] args) {

	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	public static boolean canCross(int stones[]) {
		
//		int unitJumps[] = new int[stones.length];
//		unitJumps[0] = 1;
//
//		int index = 0;
//		
//		while(index >= 0 || index < stones.length-1) {
//			
//			if(unitJumps[index] == 0) {
//				--index;
//				continue;
//			}
//			
//			int unit = stones[index+1] - stones[index];
//			
//			if(unit == unitJumps[index]
//					|| unit == unitJumps[index]+1
//					|| unit == unitJumps[index]-1) {
//				unitJumps[++index] = unit;
//			} else {
//				unitJumps[index--] = 0;
//			}
//		}
		
	}
	
	public static boolean canCrossHelper(int index, int lastJump, int stones[]) {
		if(index >= stones.length -1) return true;
		
		for(int i = index+1; i < stones.length; ++i) {
			(stones[i] - stones[index]
		}
		
		boolean high = canCrossHelper();
		boolean equal = canCrossHelper();
		boolean less = canCrossHelper(index, lastJump, stones);
	}
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.3 Tabulation + SO
	public static int climbStairs3(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-14 17:12:08.672
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-14 17:12:08.673
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-14 17:12:11.076
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

public class DynamicProgramming1 {

	public static void main(String[] args) {

	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	public static boolean canCross(int stones[]) {
		
//		int unitJumps[] = new int[stones.length];
//		unitJumps[0] = 1;
//
//		int index = 0;
//		
//		while(index >= 0 || index < stones.length-1) {
//			
//			if(unitJumps[index] == 0) {
//				--index;
//				continue;
//			}
//			
//			int unit = stones[index+1] - stones[index];
//			
//			if(unit == unitJumps[index]
//					|| unit == unitJumps[index]+1
//					|| unit == unitJumps[index]-1) {
//				unitJumps[++index] = unit;
//			} else {
//				unitJumps[index--] = 0;
//			}
//		}
		
	}
	
	public static boolean canCrossHelper(int index, int lastJump, int stones[]) {
		if(index >= stones.length -1) return true;
		
		for(int i = index+1; i < stones.length; ++i) {
			(stones[i] - stones[index])
		}
		
		boolean high = canCrossHelper();
		boolean equal = canCrossHelper();
		boolean less = canCrossHelper(index, lastJump, stones);
	}
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.3 Tabulation + SO
	public static int climbStairs3(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-14 17:12:11.076
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-14 17:12:11.077
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-14 17:12:11.083
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

public class DynamicProgramming1 {

	public static void main(String[] args) {

	}
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	public static boolean canCross(int stones[]) {
		
//		int unitJumps[] = new int[stones.length];
//		unitJumps[0] = 1;
//
//		int index = 0;
//		
//		while(index >= 0 || index < stones.length-1) {
//			
//			if(unitJumps[index] == 0) {
//				--index;
//				continue;
//			}
//			
//			int unit = stones[index+1] - stones[index];
//			
//			if(unit == unitJumps[index]
//					|| unit == unitJumps[index]+1
//					|| unit == unitJumps[index]-1) {
//				unitJumps[++index] = unit;
//			} else {
//				unitJumps[index--] = 0;
//			}
//		}
		
	}
	
	public static boolean canCrossHelper(int index, int lastJump, int stones[]) {
		if(index >= stones.length -1) return true;
		
		for(int i = index+1; i < stones.length; ++i) {
			(stones[i] - stones[index])
		}
		
		boolean high = canCrossHelper();
		boolean equal = canCrossHelper();
		boolean less = canCrossHelper(index, lastJump, stones);
	}
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.3 Tabulation + SO
	public static int climbStairs3(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-14 17:12:11.083
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-14 17:12:11.084
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-01-14 22:50:12.879 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-14 22:50:16.768
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-14 22:50:16.768
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-14 22:50:20.621
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-15 15:53:26.049 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-15 15:53:30.257
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-15 15:53:30.257
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70c31b17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-15 15:53:34.341
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-15 16:43:14.416 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-15 16:43:17.461
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-15 16:43:17.461
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-15 16:43:21.062
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-16 07:38:53.980 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-16 07:38:58.060
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-16 07:38:58.060
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-16 07:39:02.611
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-17 15:36:40.979 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-17 15:36:44.893
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-17 15:36:44.893
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-17 15:36:49.142
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-18 15:14:10.275 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-18 15:14:14.271
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-18 15:14:14.271
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-18 15:14:18.289
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-18 22:55:37.674 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-18 22:55:41.749
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-18 22:55:41.749
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-18 22:55:45.798
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-20 14:27:22.900 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-20 14:27:27.123
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-20 14:27:27.123
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-20 14:27:31.403
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-20 15:48:10.911 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-20 15:48:13.986
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-20 15:48:13.986
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5072e638,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3129299f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-20 15:48:17.069
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.jobs 4 2 2022-01-20 15:48:22.258
!MESSAGE An internal error occurred during: "Deferred Early Start".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.equinox.log.ExtendedLogReaderService.addLogListener(org.osgi.service.log.LogListener, org.eclipse.equinox.log.LogFilter)" because "logReader" is null
	at org.eclipse.core.internal.runtime.InternalPlatform.lambda$11(InternalPlatform.java:363)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
	at org.eclipse.core.internal.runtime.InternalPlatform.getLog(InternalPlatform.java:358)
	at org.eclipse.core.runtime.Plugin.getLog(Plugin.java:237)
	at org.eclipse.oomph.util.OomphPlugin.getLog(OomphPlugin.java:221)
	at org.eclipse.oomph.util.OomphPlugin.log(OomphPlugin.java:236)
	at org.eclipse.oomph.util.OomphPlugin.log(OomphPlugin.java:247)
	at org.eclipse.oomph.internal.ui.EarlyStart.run(EarlyStart.java:122)
	at org.eclipse.oomph.internal.ui.EarlyStart$1.run(EarlyStart.java:97)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-01-21 11:48:04.285 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-21 11:48:08.667
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-21 11:48:08.667
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3129299f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f73f0c7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-21 11:48:13.403
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-21 18:42:40.612 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-21 18:42:44.676
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-21 18:42:44.676
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-21 18:42:48.709
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-21 22:13:52.000 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-21 22:13:56.796
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-21 22:13:56.796
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-21 22:14:01.610
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-01-21 23:23:27.717 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-21 23:23:31.031
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-21 23:23:31.031
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-21 23:23:34.687
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
