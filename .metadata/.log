!SESSION 2022-01-31 14:53:06.371 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file E:\Programming\Java\.metadata\.bak_0.log
Created Time: 2022-01-31 16:41:14.995

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:14.995
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666 -9555}
		{0 0 0 0 0}
		{-99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-31 16:41:14.998
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-31 16:41:14.998
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:15.994
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0 0 0 0 0}
		{-99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-31 16:41:15.996
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-31 16:41:15.997
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:16.017
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0 0 0 0 0}
		{-99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-31 16:41:16.019
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-31 16:41:16.019
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:17.514
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0 0 0 0 0}
		{-,99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-31 16:41:17.515
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-31 16:41:17.516
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:17.525
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0 0 0 0 0}
		{-,99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-31 16:41:17.526
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-31 16:41:17.526
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:17.537
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0 0 0 0 0}
		{-,99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-31 16:41:17.538
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-31 16:41:17.538
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:19.030
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0 0 0 0 0}
		{-99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-31 16:41:19.031
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-31 16:41:19.031
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:19.041
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0 0 0 0 0}
		{-99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-31 16:41:19.042
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-31 16:41:19.042
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:19.523
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0 0 0 0 0}
		{-99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-31 16:41:19.524
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-31 16:41:19.524
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:20.659
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0 0 0 0 0}
		{-99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-31 16:41:20.660
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-31 16:41:20.661
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:22.049
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0, 0, 0 0 0}
		{-99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-31 16:41:22.050
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-31 16:41:22.051
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:23.569
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0, 0, 0, 0, 0}
		{-99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-31 16:41:23.570
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-31 16:41:23.571
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:23.578
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0, 0, 0, 0, 0}
		{-99 -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-31 16:41:23.579
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-31 16:41:23.580
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:25.587
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0, 0, 0, 0, 0}
		{-99, -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-31 16:41:25.588
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-31 16:41:25.588
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:25.627
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0, 0, 0, 0, 0}
		{-99, -98 -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-31 16:41:25.628
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-31 16:41:25.629
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:26.605
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0, 0, 0, 0, 0}
		{-99, -98, -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-31 16:41:26.607
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-31 16:41:26.607
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:26.623
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0, 0, 0, 0, 0}
		{-99, -98, -97 -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-31 16:41:26.624
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-31 16:41:26.625
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:28.128
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0, 0, 0, 0, 0}
		{-99, -98, -97, -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-01-31 16:41:28.130
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-01-31 16:41:28.131
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-01-31 16:41:28.152
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package dynamicProgramming;

import java.util.*;

public class DynamicProgramming1 {

	static int mod = (int)(1e9 + 7);
	
	public static void main(String[] args) {
		
		int arr[][] = {{1, 2, 10, 4}, {100, 3, 2, 1}, {1, 1, 20, 2}, {1, 2, 2, 1}};
		int arr1[][] = {{-10000000}};
		int arr2[][] = {};
		
		
		{-9999, -9888, -9777, -9666, -9555}
		{1, 10, 2, 4, 5}
		{-9999, -9888, -9777, -9666, -9555}
		{0, 0, 0, 0, 0}
		{-99, -98, -97, -96 -95}
		System.out.println(getMaxPathSum3(arr1));
		
	}
	
	/* ------------------------------------------------------------------ */

	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
	
	/* ------------------------------------------------------------------ */
			// DP on Grids: Minimum Falling Path Sum | Variable Starting and Ending Points
	
	// 12.1
	public static int getMaxPathSum1(int[][] matrix) {
		
		int col = matrix[0].length;
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum1Helper(0, j, matrix);
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum1Helper(int i, int j, int[][] matrix) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		int left = matrix[i][j] + getMaxPathSum1Helper(i+1, j-1, matrix);
		int below = matrix[i][j] + getMaxPathSum1Helper(i+1, j, matrix);
		int right = matrix[i][j] + getMaxPathSum1Helper(i+1, j+1, matrix);
		
		return Math.max(left, Math.max(below, right));
	}
	
	// 12.2
	public static int getMaxPathSum2(int[][] matrix) {
		
		int row = matrix.length;
		int col = matrix[0].length;
		
		Integer dp[][] = new Integer[row][col];
		
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			int curr = getMaxPathSum2Helper(0, j, matrix, dp);
			
			max = Math.max(max, curr);
		}
		
		return max;
	}
	
	public static int getMaxPathSum2Helper(int i, int j, int[][] matrix, Integer[][] dp) {
		
		if(j < 0 || j > matrix[0].length-1) return -(int)(1e9);
		if(matrix.length-1 == i) return matrix[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int left = matrix[i][j] + getMaxPathSum2Helper(i+1, j-1, matrix, dp);
		int below = matrix[i][j] + getMaxPathSum2Helper(i+1, j, matrix, dp);
		int right = matrix[i][j] + getMaxPathSum2Helper(i+1, j+1, matrix, dp);
		
		return dp[i][j] = Math.max(left, Math.max(below, right));
	}
	
	// 12.3
	public static int getMaxPathSum3(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int dp[][] = new int[row][col];
		int max = Integer.MIN_VALUE;
		
		for(int j = 0; j < col; ++j) {
			dp[row-1][j] = matrix[row-1][j];
			max = Math.max(max, dp[row-1][j]);
		}
		
		
		for(int i = row-2; i >= 0; --i) {
			for(int j = 0; j < col; ++j) {
				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
				
				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
				below = matrix[i][j] + dp[i+1][j];
				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
				
				dp[i][j] = Math.max(left, Math.max(below, right));
				
				max = Math.max(max, dp[i][j]);
			}
		}
		
		return max;
	}
	
	// 12.4
	public static int getMaxPathSum4(int[][] matrix) {
		int row = matrix.length;
		int col = matrix[0].length;
		
		int prev[] = new int[col];
		
		for(int j = 0; j < col; ++j) prev[j] = matrix[row-1][j];
		
		int max = Integer.MIN_VALUE;
		
//		for(int i = row-2; i >= 0; --i) {
//			for(int j = 0; j < col; ++j) {
//				int left = Integer.MIN_VALUE, below = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
//				
//				if(j > 0) left = matrix[i][j] + dp[i+1][j-1];
//				below = matrix[i][j] + dp[i+1][j];
//				if(j < col-1) right = matrix[i][j] + dp[i+1][j+1];
//				
//				dp[i][j] = Math.max(left, Math.max(below, right));
//				
//				max = Math.max(max, dp[i][j]);
//			}
//		}
		
		return max;
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Triangle
	
	// 11.1
	public static int minimumPathSum1(int[][] triangle, int n) {
		return minimumPathSum1Helper(0, 0, triangle, n-1);
	}
	
	public static int minimumPathSum1Helper(int i, int j, int[][] triangle, int n) {
		
		if(i == n) return triangle[i][j];
		
		int down = triangle[i][j] + minimumPathSum1Helper(i+1, j, triangle, n);
		int diagonal = triangle[i][j] + minimumPathSum1Helper(i+1, j+1, triangle, n);
		
		return Math.min(down, diagonal);
	}
	
	// 11.2
	public static int minimumPathSum2(int[][] triangle, int n) {
		Integer dp[][] = new Integer[n][n];
		return minimumPathSum2Helper(0, 0, triangle, n-1, dp);
	}
	
	public static int minimumPathSum2Helper(int i, int j, int[][] triangle, int n, Integer dp[][]) {
		
		if(i == n) return triangle[i][j];
		
		if(dp[i][j] != null) return dp[i][j];
		
		int down = triangle[i][j] + minimumPathSum2Helper(i+1, j, triangle, n, dp);
		int diagonal = triangle[i][j] + minimumPathSum2Helper(i+1, j+1, triangle, n, dp);
		
		return dp[i][j] = Math.min(down, diagonal);
	}
	
	// 11.3
	public static int minimumPathSum3(int[][] triangle, int n) {
		
		int dp[][] = new int[n][n];
		
		for(int i = 0; i < n; ++i) dp[n-1][i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			for(int j = i; j >= 0; --j) {
				dp[i][j] = triangle[i][j] + Math.min(dp[i+1][j], dp[i+1][j+1]);
			}
		}
		
		return dp[0][0];
	}
	
	// 11.4
	public static int minimumPathSum4(int[][] triangle, int n) {
		
		int prev[] = new int[n];
		
		for(int i = 0; i < n; ++i) prev[i] = triangle[n-1][i];
		
		for(int i = n-2; i >= 0; --i) {
			int curr[] = new int[n];
			
			for(int j = i; j >= 0; --j) curr[j] = triangle[i][j] + Math.min(prev[j], prev[j+1]);
			
			prev = curr;
		}
		
		return prev[0];
	}
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Minimum Path Sum
	
	// 10.1
	public static int minSumPath1(int[][] grid) {
		return minSumPath1Helper(grid.length-1, grid[0].length-1, grid);
	}
	
	public static int minSumPath1Helper(int m, int n, int[][] grid) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		int up = minSumPath1Helper(m-1, n, grid) + grid[m][n];
		int left = minSumPath1Helper(m, n-1, grid) + grid[m][n];
		
		return Math.min(up, left);
	}
	
	// 10.2
	public static int minSumPath2(int[][] grid) {
		int dp[][] = new int[grid.length][grid[0].length];
		return minSumPath2Helper(grid.length-1, grid[0].length-1, grid, dp);
	}
	
	public static int minSumPath2Helper(int m, int n, int[][] grid, int dp[][]) {
		
		if(m == 0 && n == 0) return grid[0][0];
		if(m < 0 || n < 0) return (int)(1e9);
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = minSumPath2Helper(m-1, n, grid, dp) + grid[m][n];
		int left = minSumPath2Helper(m, n-1, grid, dp) + grid[m][n];
		
		return dp[m][n] = Math.min(up, left);
	}
	
	// 10.3
	public static int minSumPath3(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int dp[][] = new int[m][n];
		
		for(int i = 0; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) dp[i][j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = dp[i-1][j] + grid[i][j];
					if(j > 0) left = dp[i][j-1] + grid[i][j];
				
					dp[i][j] = Math.min(up, left);
				}
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 10.4
	public static int minSumPath4(int[][] grid) {
		
		int m = grid.length;
		int n = grid[0].length;
		
		int prev[] = new int[n];
		
		for(int i = 0; i < m; ++i) {
			
			int temp[] = new int[n];
			for(int j = 0; j < n; ++j) {
				
				if(i == 0 && j == 0) temp[j] = grid[i][j];
				else {
					int up = Integer.MAX_VALUE, left = Integer.MAX_VALUE;
					
					if(i > 0) up = prev[j] + grid[i][j];
					if(j > 0) left = temp[j-1] + grid[i][j];
				
					temp[j] = Math.min(up, left);
				}
			}
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	
	/* ------------------------------------------------------------------ */
							// DP on GRIDS : Unique Paths 2
	
	// 9.1
	public static int mazeObstacles1(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		return mazeObstacles1Helper(n-1, m-1, mat);
	}
	
	public static int mazeObstacles1Helper(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
		int up = mazeObstacles1Helper(n-1, m, mat);
		int left = mazeObstacles1Helper(n, m-1, mat);
		
		return (up + left) % mod;
	}
	
	// 9.2
	public static int mazeObstacles2(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		int dp[][] = new int[n][m];
		return mazeObstacles2Helper(n-1, m-1, mat, dp);
	}
	
	public static int mazeObstacles2Helper(int n, int m, ArrayList<ArrayList<Integer>> mat, int dp[][]) {
		if(n >= 0 && m >= 0 && mat.get(n).get(m) == -1) return 0;
		if(n == 0 && m == 0) return 1;
		if(n < 0 || m < 0) return 0;
		
        if(dp[n][m] > 0) return dp[n][m];
        
		int up = mazeObstacles2Helper(n-1, m, mat, dp);
		int left = mazeObstacles2Helper(n, m-1, mat, dp);
		
		return dp[n][m] = (up + left) % mod;
	}
	
	// 9.3
	public static int mazeObstacles3(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int dp[][] = new int[n][m];

		for(int i = 0; i < n; ++i) {
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) dp[i][j] = 0;
				else if(i == 0 && j == 0) dp[i][j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = dp[i-1][j];
					if(j > 0) left = dp[i][j-1];
					dp[i][j] = (up + left) % mod;
				}
				
			}
		}
		
		return dp[n-1][m-1];
	}
	
	// 9.4
	public static int mazeObstacles4(int n, int m, ArrayList<ArrayList<Integer>> mat) {
		
		int prev[] = new int[m];

		for(int i = 0; i < n; ++i) {
			
			int temp[] = new int[m];
			for(int j = 0; j < m; ++j) {
				
				if(mat.get(i).get(j) == -1) temp[j] = 0;
				else if(i == 0 && j == 0) temp[j] = 1;
				else {
					int up = 0, left = 0;
					if(i > 0) up = prev[j];
					if(j > 0) left = temp[j-1];
					temp[j] = (up + left) % mod;
				}
			}
			prev = temp;
		}
		
		return prev[m-1];
	}
	
	/* ------------------------------------------------------------------ */
	
							// DP on GRIDS : Unique Paths
	// 8.1
	public static int uniquePaths1(int m, int n) {
		return uniquePaths1Helper(m-1, n-1);
	}
	
	public static int uniquePaths1Helper(int m, int n) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		int up = uniquePaths1Helper(m-1, n);
		int left = uniquePaths1Helper(m, n-1);
		
		return up+left;
	}
	
	// 8.2
	public static int uniquePaths2(int m, int n) {
		int dp[][] = new int[m][n];
		return uniquePaths2Helper(m-1, n-1, dp);
	}
	
	public static int uniquePaths2Helper(int m, int n, int dp[][]) {
		if(m == 0 && n == 0) return 1;
		if(m < 0 || n < 0) return 0;
		
		if(dp[m][n] > 0) return dp[m][n];
		
		int up = uniquePaths2Helper(m-1, n, dp);
		int left = uniquePaths2Helper(m, n-1, dp);
		
		return dp[m][n] = up+left;
	}
	
	// 8.3
	public static int uniquePaths3(int m, int n) {
		
		int dp[][] = new int[m][n];
		
		Arrays.fill(dp[0], 1);
		
		for(int i = 1; i < m; ++i) {
			for(int j = 0; j < n; ++j) {
				if(j == 0) dp[i][j] = dp[i-1][j];
				else dp[i][j] = dp[i-1][j] + dp[i][j-1];
			}
		}
		
		return dp[m-1][n-1];
	}
	
	// 8.4
	public static int uniquePaths4(int m, int n) {
		
		int prev[] = new int[n];
		
		Arrays.fill(prev, 1);
		
		for(int i = 1; i < m; ++i) {
			int temp[] = new int[n];
			
			for(int j = 0; j < n; ++j) {
				if(j == 0) temp[j] = prev[j]; 
				else temp[j] = temp[j-1] + prev[j];
			}
			
			prev = temp;
		}
		
		return prev[n-1];
	}
	
	/* ------------------------------------------------------------------ */
					
						// Ninja's training.
	
	// 7.1
	public static int ninjaTraining1(int n, int points[][]) {
		return ninjaTraining1Helper(n-1, 3, points);
	}
	
	public static int ninjaTraining1Helper(int n, int lastPicked, int points[][]) {
		
		if(n == -1) return 0;
		
		int first = 0;
		int second = 0;
		int third = 0;
				
		if(lastPicked != 0) first = ninjaTraining1Helper(n-1, 0, points) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining1Helper(n-1, 1, points) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining1Helper(n-1, 2, points) + points[n][2];
		
		return Math.max(first, Math.max(second, third));
		
	}
	
	// 7.2
	public static int ninjaTraining2(int n, int points[][]) {
		
		int dp[][] = new int[n][4];

		return ninjaTraining2Helper(n-1, 3, points, dp);
	}
	
	public static int ninjaTraining2Helper(int n, int lastPicked, int points[][], int dp[][]) {
		
		if(n == -1) return 0;
		
		if(dp[n][lastPicked] != 0) return dp[n][lastPicked];
		
		int first = 0, second = 0, third = 0;
		
		if(lastPicked != 0) first = ninjaTraining2Helper(n-1, 0, points, dp) + points[n][0];
		if(lastPicked != 1) second = ninjaTraining2Helper(n-1, 1, points, dp) + points[n][1];
		if(lastPicked != 2) third = ninjaTraining2Helper(n-1, 2, points, dp) + points[n][2];
		
		return dp[n][lastPicked] = Math.max(first, Math.max(second, third));
		
	}
	
	// 7.3
	public static int ninjaTraining3(int n, int points[][]) {
		
		int dp[][] = new int[n][4];
		
		dp[0][0] = Math.max(points[0][1], points[0][2]);
		dp[0][1] = Math.max(points[0][0], points[0][2]);
		dp[0][2] = Math.max(points[0][0], points[0][1]);
		dp[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
					
				int first = 0, second = 0, third = 0;
				
				if(lastPicked != 0) first = dp[day-1][0] + points[day][0];
				if(lastPicked != 1) second = dp[day-1][1] + points[day][1];
				if(lastPicked != 2) third = dp[day-1][2] + points[day][2];
				
				dp[day][lastPicked] = Math.max(first, Math.max(second, third));
				
			}
			
		}
		
		return dp[n-1][3];
		
	}
	
	// 7.4
	public static int ninjaTraining4(int n, int points[][]) {
		
		int prev[] = new int[4];
		
		prev[0] = Math.max(points[0][1], points[0][2]);
		prev[1] = Math.max(points[0][0], points[0][2]);
		prev[2] = Math.max(points[0][0], points[0][1]);
		prev[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));
		
		for(int day = 1; day < n; ++day) {
			
			int temp[] = new int[4];
			
			for(int lastPicked = 0; lastPicked <= 3; ++lastPicked) {
				
				int first = 0;
				int second = 0;
				int third = 0;
				
				if(lastPicked != 0) first = prev[0] + points[day][0];
				if(lastPicked != 1) second = prev[1] + points[day][1];
				if(lastPicked != 2) third = prev[2] + points[day][2];
				
				temp[lastPicked] = Math.max(first, Math.max(second, third));
			}
			
			prev = temp;
		}
		
		return prev[3];
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// This question 95% similar to Q5.
	
	// 6.2
	public static long houseRobber2(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		ArrayList<Integer> valueInHouseTemp = new ArrayList<Integer>();
		
		for(int i = 0; i < valueInHouse.length; ++i) {
			valueInHouseTemp.add(valueInHouse[i]);
		}
		
		long dp[] = new long[valueInHouseTemp.size()-1];
		
		valueInHouseTemp.remove(0);		// Skip first
		System.out.println(valueInHouseTemp);
		long ans1 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		Arrays.fill(dp, 0);
		valueInHouseTemp.add(0, valueInHouse[0]);	// Adding first
		
		
		valueInHouseTemp.remove(valueInHouseTemp.size()-1);	// Removing last
		System.out.println(valueInHouseTemp);
		long ans2 = houseRobber2Helper(valueInHouseTemp.size()-1, valueInHouseTemp, dp);
		
		return Math.max(ans1, ans2);
		
	}
	
	public static long houseRobber2Helper(int index, ArrayList<Integer> nums, long dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		long notPick = houseRobber2Helper(index-1, nums, dp);
		long pick = houseRobber2Helper(index-2, nums, dp) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 6.4
	public static long houseRobber4(int[] valueInHouse) {
		
		if(valueInHouse.length == 1) return valueInHouse[0];
		
		long prev = valueInHouse[0];
		long prev2 = 0;
		
		for(int i = 1; i < valueInHouse.length-1; ++i) {		// Skipping last
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		long ans1 = prev;
		
		prev = valueInHouse[1];
		prev2 = 0;
		for(int i = 2; i < valueInHouse.length; ++i) {			// Skipping first
			
			long curr = Math.max(prev2 + valueInHouse[i], prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return Math.max(ans1, prev);
		
	}
	
	/* ------------------------------------------------------------------ */
	
	// 5.1
	public static int maximumNonAdjacentSum1(ArrayList<Integer> nums) {
		return maximumNonAdjacentSum1Helper(nums.size()-1, nums);
	}
	
	public static int maximumNonAdjacentSum1Helper(int index, ArrayList<Integer> nums) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return Math.max(notPick, pick);
		
	}
	
	// 5.2
	public static int maximumNonAdjacent2Sum(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		return maximumNonAdjacentSum2Helper(nums.size()-1, nums, dp);
		
	}
	
	public static int maximumNonAdjacentSum2Helper(int index, ArrayList<Integer> nums, int dp[]) {
		
		if(index == 0) return nums.get(0);
		if(index < 0) return 0;
		
		if(dp[index] != 0) return dp[index];
		
		int notPick = maximumNonAdjacentSum1Helper(index-1, nums);
		int pick = maximumNonAdjacentSum1Helper(index-2, nums) + nums.get(index);
		
		return dp[index] = Math.max(notPick, pick);
		
	}
	
	// 5.3
	public static int maximumNonAdjacentSum3(ArrayList<Integer> nums) {
		
		int dp[] = new int[nums.size()];
		dp[0] = nums.get(0);
		
		for(int i = 1; i < nums.size(); ++i) {
		
			if(i >= 2) dp[i] = Math.max(dp[i-2] + nums.get(i), dp[i-1]);
			else if(i == 1) dp[i] = Math.max(0 + nums.get(i), dp[i-1]);
		}
		
		return dp[nums.size()-1];
		
	}
	
	// 5.4
	public static int maximumNonAdjacentSum4(ArrayList<Integer> nums) {
		
		int prev = nums.get(0);
		int prev2 = 0;
		
		for(int i = 1; i < nums.size(); ++i) {
			
			int curr = Math.max(prev2 + nums.get(i), prev);
			prev2 = prev;
			prev = curr;
			
		}
		
		return prev;
		
	}
	
	/* ------------------------------------------------------------------ */

						// LEC : A follow-up problem.
	
	/* ------------------------------------------------------------------ */
	
				// Frop Jump: Minimum energy required to reach the Nth stair.
	
	// 3.1
	// n = Nth stair(heights[].length) and heights[i] = energy required at each stair.
	public static int frogJump1(int n, int heights[]) {

		return frogJump1Helper(n-1, heights);
		
	}
	
	public static int frogJump1Helper(int n, int heights[]) {
		if(n == 0) return 0;
        
        int l = frogJump1Helper(n-1, heights) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump1Helper(n-2, heights) + Math.abs(heights[n] - heights[n-2]);
        
		return Math.min(l, r);
		
	}
	
	// 3.2
	public static int frogJump2(int n, int heights[]) {
		int dp[] = new int[n+1];
		Arrays.fill(dp, -1);
		return frogJump2Helper(n-1, heights, dp);
		
	}
	
	public static int frogJump2Helper(int n, int heights[], int dp[]) {
		if(n == 0) return 0;
        
		if(dp[n] != -1) return dp[n]; 
		
        int l = frogJump2Helper(n-1, heights, dp) + Math.abs(heights[n] - heights[n-1]);
        int r = Integer.MAX_VALUE;
        if(n > 1) r = frogJump2Helper(n-2, heights, dp) + Math.abs(heights[n] - heights[n-2]);
        
		return dp[n] = Math.min(l, r);
		
	}
	
	// 3.3
	public static int frogJump3(int n, int heights[]) {
		
		int dp[] = new int[n];
		dp[0] = 0;
		
		for(int i = 1; i < n; ++i) {
			int first  = dp[i-1] + Math.abs(heights[i] - heights[i-1]);
			int second = Integer.MAX_VALUE;
			if(i >= 2) second = dp[i-2] + Math.abs(heights[i] - heights[i-2]);
			
			dp[i] = Math.min(first, second);
		}
		
		return dp[n-1];
		
	}
	
	// 3.4
	public static int frogJump4(int n, int heights[]) {
		
		int first = 0;
		int second = 0;
		
		for(int i = 1; i < n; ++i) {
			
			int energy1 = first + Math.abs(heights[i] - heights[i-1]); 
			
			int energy2 = Integer.MAX_VALUE;
			if(i >= 2) energy2 = second + Math.abs(heights[i] - heights[i-2]);
			
			second = first;
			first = Math.min(energy1, energy2);
		}
		
		return first;
		
	}
	
	
	/* ------------------------------------------------------------------ */
	
		// Count the total number of ways to climb to the nth stair, 99% same as fibonacci(P1).
	
	// 2.1 Normal recursive, no optimization.
	public static int climbStairs1(int n) {
		
		if(n == 0) return 1;
		if(n == -1) return 1;
		
		int l = climbStairs1(n-1);
		int r = climbStairs1(n-2);
		
		return l + r;
	}
	
	// 2.2 Memoization.
	public static int climbStairs2(int n, int dp[]) {
		
		if(n == 0) return 0;
		if(n == 1) return 1;
		if(n == 2) return 2;
		
		if(dp[n] != -1) return dp[n];
		
		int l = climbStairs2(n-1, dp);
		int r = climbStairs2(n-2, dp);
		
		return dp[n] = l + r;
	}
	
	// 2.4 Tabulation + SO
	public static int climbStairs4(int n) {

		int oneStepAway = 1;
		int twoStepAway = 2;
		
		if(n == 0) return 0;
		if(n == 1) return oneStepAway;
		if(n == 2) return twoStepAway;
		
		for(int i = 3; i <= n; ++i) {
			int totalWays = oneStepAway + twoStepAway;
			twoStepAway = oneStepAway;
			oneStepAway = totalWays;
		}
		
		return oneStepAway;
	}
	
		/* ------------------------------------------------------------------ */
	
							// Find the nth fibonacci number.
	
	// 1.1 Normal recursive, no optimization.
	public static int fibonacci1(int n) {
		if(n <= 1) return n;
		
		return fibonacci1(n - 1) + fibonacci1(n - 2);
	}
	
	// 1.2 Memoization.
	// dp[] : Length = n + 1 && by default, values at all indexes should be -1
	public static int fibonacci2(int n, int dp[]) {
		if(n <= 1) return n;
		
		if(dp[n] != -1) return dp[n];
		
		return dp[n] = fibonacci2(n - 1, dp) + fibonacci2(n - 2, dp);
	}
	
	// 1.3 Tabulation.
	public static int fibonacci3(int n) {
		
		int dp[] = new int[n+1];
		dp[0] = 0;
		dp[1] = 1;
		
		for(int i = 2; i <= n; ++i) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		
		return dp[n];
	}
	
	// 1.3 Tabulation + Space optimization.
	public static int fibonacci4(int n) {
		
		int prev1 = 1;
		int prev2 = 0;
		
		for(int i = 2; i <= n; ++i) {
			int curr = prev1 + prev2;
			prev2 = prev1;
			prev1 = curr;
		}
		
		return prev1;
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-01-31 16:41:28.152
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-01-31 16:41:28.152
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-01-31 22:42:28.354 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-01-31 22:42:32.395
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-01-31 22:42:32.395
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-01-31 22:42:36.514
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-01 15:10:47.605 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-01 15:10:51.647
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-01 15:10:51.647
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-01 15:10:56.085
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-02 18:13:30.133 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-02 18:13:34.338
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-02 18:13:34.338
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-02 18:13:38.658
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-03 11:21:39.165 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-03 11:21:43.845
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-03 11:21:43.845
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.equinox.app 4 2 2022-02-03 11:21:48.850
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.equinox.app".
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4893)
	at org.eclipse.swt.SWT.error(SWT.java:4808)
	at org.eclipse.swt.SWT.error(SWT.java:4779)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:445)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:364)
	at org.eclipse.swt.widgets.Shell.close(Shell.java:547)
	at org.eclipse.ui.splash.AbstractSplashHandler.dispose(AbstractSplashHandler.java:65)
	at org.eclipse.ui.internal.Workbench$3$1.applicationRunning(Workbench.java:802)
	at org.eclipse.equinox.internal.app.EclipseAppHandle$1.run(EclipseAppHandle.java:279)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.applicationRunning(EclipseAppHandle.java:267)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1087)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-03 11:21:48.921
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.jobs 4 2 2022-02-03 11:21:54.278
!MESSAGE An internal error occurred during: "Deferred Early Start".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.equinox.log.ExtendedLogReaderService.addLogListener(org.osgi.service.log.LogListener, org.eclipse.equinox.log.LogFilter)" because "logReader" is null
	at org.eclipse.core.internal.runtime.InternalPlatform.lambda$11(InternalPlatform.java:363)
	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1708)
	at org.eclipse.core.internal.runtime.InternalPlatform.getLog(InternalPlatform.java:358)
	at org.eclipse.core.runtime.Plugin.getLog(Plugin.java:237)
	at org.eclipse.oomph.util.OomphPlugin.getLog(OomphPlugin.java:221)
	at org.eclipse.oomph.util.OomphPlugin.log(OomphPlugin.java:236)
	at org.eclipse.oomph.util.OomphPlugin.log(OomphPlugin.java:247)
	at org.eclipse.oomph.internal.ui.EarlyStart.run(EarlyStart.java:122)
	at org.eclipse.oomph.internal.ui.EarlyStart$1.run(EarlyStart.java:97)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-02-03 15:46:55.740 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-03 15:46:59.559
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-03 15:46:59.559
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3129299f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f73f0c7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-03 15:47:03.302
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-03 22:03:36.374 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-03 22:03:39.963
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-03 22:03:39.963
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-03 22:03:45.164
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-04 15:37:36.275 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-04 15:37:40.454
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-04 15:37:40.454
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11015ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-04 15:37:45.109
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-04 18:29:20.403 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-04 18:29:23.706
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-04 18:29:23.706
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-04 18:29:27.110
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-05 13:14:00.078 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-05 13:14:04.684
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-05 13:14:04.684
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-05 13:14:09.165
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-02-05 13:22:34.055
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package bits;

public class BitManipulation {

	public static void main(String[] args) {
		

	}
	
	public static void countSetBits(int num) {
	// num is +ve number.
		
		int count = 0;
		for(int i = 0; i < 31; ++i) {
			if((num & 1) == 1) ++count; 
			num >> 1
		}
		
		
	}
	
	public static void checkifKthBitIsSet(int num, int k) {
		
		if((num >> (k-1) & 1) == 0) System.out.println("YES");
		else System.out.println("NO");
		
	}
	
	// Odd/Even finder using Bit manipulation.
	public static void oddEvenUsingBits(int num) {
		
		if((num&1) == 0) {
			System.out.println("Even");
		} else {
			System.out.println("Odd");
		}
	}
	
	// Swaping variables using Bit manipulation.
	public static void swapVariablesUsingBits(int var1, int var2) {
		
		var1 = var1 ^ var2;
		var2 = var1 ^ var2;
		var1 = var1 ^ var2;
		System.out.println("Var1 = " +var1 + " and Var2 = " +var2);
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2216)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2996)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-05 13:22:34.057
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2216)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2996)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-05 13:22:34.058
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2216)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2996)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-05 13:22:34.067
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package bits;

public class BitManipulation {

	public static void main(String[] args) {
		

	}
	
	public static void countSetBits(int num) {
	// num is +ve number.
		
		int count = 0;
		for(int i = 0; i < 31; ++i) {
			if((num & 1) == 1) ++count; 
			num >> 1
		}
		
		
	}
	
	public static void checkifKthBitIsSet(int num, int k) {
		
		if((num >> (k-1) & 1) == 0) System.out.println("YES");
		else System.out.println("NO");
		
	}
	
	// Odd/Even finder using Bit manipulation.
	public static void oddEvenUsingBits(int num) {
		
		if((num&1) == 0) {
			System.out.println("Even");
		} else {
			System.out.println("Odd");
		}
	}
	
	// Swaping variables using Bit manipulation.
	public static void swapVariablesUsingBits(int var1, int var2) {
		
		var1 = var1 ^ var2;
		var2 = var1 ^ var2;
		var1 = var1 ^ var2;
		System.out.println("Var1 = " +var1 + " and Var2 = " +var2);
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2216)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2996)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-05 13:22:34.067
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2216)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2996)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-05 13:22:34.068
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2216)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2996)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2972)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2206)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2993)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-02-05 15:49:01.458 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-05 15:49:05.275
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-05 15:49:05.275
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-05 15:49:09.022
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-05 17:06:12.675 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-05 17:06:15.836
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-05 17:06:15.836
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-05 17:06:20.177
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.touchpoint.natives 2 0 2022-02-05 17:11:50.916
!MESSAGE Could not remove temporary backup directory (it is safe to manually delete it and its contents): C:\Users\Ayush\AppData\Local\Temp\C__Users_Ayush_eclipse_java-2021-09_eclipse_3b0731e2-8df5-4940-92ac-a8a961ce8c41
!SESSION 2022-02-05 17:12:14.380 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data file:/E:/Programming/Java/ -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-05 17:30:30.740
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-05 17:30:30.740
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@222eda8a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3331800f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-05 17:30:30.740
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@c414eb3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4edd8a0a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-05 17:30:34.724
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.e4.ui.workbench 2 0 2022-02-05 17:30:34.734
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.search.SearchResultView" id and the "Classic Search" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2022-02-05 17:30:34.744
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.wst.xml.ui.views.annotations.XMLAnnotationsView" id and the "Documentation" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2022-02-05 17:30:34.744
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.wst.xml.ui.contentmodel.view" id and the "Content Model" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled
!SESSION 2022-02-05 19:54:51.716 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-05 19:54:57.947
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-05 19:54:57.947
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-05 19:54:57.947
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-05 19:55:03.165
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-06 07:46:43.983 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-06 07:46:50.262
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-06 07:46:50.262
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-06 07:46:50.262
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-06 07:46:54.686
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-02-06 09:01:31.012
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package LeetcodeContest;

import java.util.*;

public class weekly279 {

	public static void main(String[] args) {
		int arr[] = {1};
		
		System.out.println(smallestNumber(987654012));
	}
	
	class Bitset {
		
		int size = 0;
		int num;
		
	    public Bitset(int size) {
	        this.size = size;
	        num = 0;
	    }
	    
	    public void fix(int idx) {
	        int temp = 1;
	        temp = temp << idx;
	        num = num | temp;
	    }
	    
	    public void unfix(int idx) {
	    	(n & ~(1 << (k - 1)))
	    }
	    
	    public void flip() {
	        num = ~num;
	    }
	    
	    public boolean all() {
	    	int count = 0;
			for(int i = 0; i <= size; ++i) {
				if((num & 1) == 1) ++count; 
				num = num >> 1;
			}
			
			return count == size;
	    }
	    
	    public boolean one() {
	    	int count = 0;
			for(int i = 0; i <= size; ++i) {
				if((num & 1) == 1) ++count; 
				num = num >> 1;
			}
			
			return count > 0;
	    }
	    
	    public int count() {
	    	int c = 0;
			for(int i = 0; i <= size; ++i) {
				if((num & 1) == 1) ++c; 
				num = num >> 1;
			}
			
			return c;
	    }
	    
	    public String toString() {
	        String s = Integer.toBinaryString(num);
	        return s;
	    }
	}
	
	public static long smallestNumber(long num) {
		if(num == 0) return 0;
        boolean isPos = num > 0;
        
        String s = String.valueOf(num);
        LinkedList<Character> arr = new LinkedList<>();
        int countZero = 0;
        for(int i = 0; i < s.length(); ++i) {
        	if(s.charAt(i) != '0') arr.add(s.charAt(i));
        	else ++countZero;
        }
        
        if(isPos) {
        	Collections.sort(arr);
        	for(int i = 1; i <= countZero; ++i) {
        		arr.add(1, '0');
        	}
        } else {
        	arr.remove(0);
        	Collections.sort(arr, Comparator.reverseOrder());
        	for(int i = 1; i <= countZero; ++i) {
        		arr.add('0');
        	}
        	
        	arr.add(0, '-');
        }
        
        String ans = "";
        for(int i = 0; i < arr.size(); ++i) {
        	ans += arr.get(i);
        }
        
        return Long.valueOf(ans);
        
    }
	
	public static int[] sortEvenOdd(int arr[]) {
		
		ArrayList<Integer> evenArr = new ArrayList<Integer>();
		ArrayList<Integer> oddArr = new ArrayList<Integer>();
 
        for(int i = 0; i < arr.length; i++) {
            if (i % 2 == 0) evenArr.add(arr[i]);
            else oddArr.add(arr[i]);
        }

        Collections.sort(evenArr);
        Collections.sort(oddArr, Collections.reverseOrder());
        
        int i = 0;
        for (int j = 0; j < evenArr.size(); j++) {
            arr[i] = evenArr.get(j);
            i = i + 2;
        }
        
        i = 1;
        for (int j = 0; j < oddArr.size(); j++) {
            arr[i] = oddArr.get(j);
            i = i + 2;
        }
 
        return arr;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-06 09:01:31.015
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-06 09:01:31.016
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-06 09:01:31.026
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package LeetcodeContest;

import java.util.*;

public class weekly279 {

	public static void main(String[] args) {
		int arr[] = {1};
		
		System.out.println(smallestNumber(987654012));
	}
	
	class Bitset {
		
		int size = 0;
		int num;
		
	    public Bitset(int size) {
	        this.size = size;
	        num = 0;
	    }
	    
	    public void fix(int idx) {
	        int temp = 1;
	        temp = temp << idx;
	        num = num | temp;
	    }
	    
	    public void unfix(int idx) {
	    	(n & ~(1 << (k - 1)))
	    }
	    
	    public void flip() {
	        num = ~num;
	    }
	    
	    public boolean all() {
	    	int count = 0;
			for(int i = 0; i <= size; ++i) {
				if((num & 1) == 1) ++count; 
				num = num >> 1;
			}
			
			return count == size;
	    }
	    
	    public boolean one() {
	    	int count = 0;
			for(int i = 0; i <= size; ++i) {
				if((num & 1) == 1) ++count; 
				num = num >> 1;
			}
			
			return count > 0;
	    }
	    
	    public int count() {
	    	int c = 0;
			for(int i = 0; i <= size; ++i) {
				if((num & 1) == 1) ++c; 
				num = num >> 1;
			}
			
			return c;
	    }
	    
	    public String toString() {
	        String s = Integer.toBinaryString(num);
	        return s;
	    }
	}
	
	public static long smallestNumber(long num) {
		if(num == 0) return 0;
        boolean isPos = num > 0;
        
        String s = String.valueOf(num);
        LinkedList<Character> arr = new LinkedList<>();
        int countZero = 0;
        for(int i = 0; i < s.length(); ++i) {
        	if(s.charAt(i) != '0') arr.add(s.charAt(i));
        	else ++countZero;
        }
        
        if(isPos) {
        	Collections.sort(arr);
        	for(int i = 1; i <= countZero; ++i) {
        		arr.add(1, '0');
        	}
        } else {
        	arr.remove(0);
        	Collections.sort(arr, Comparator.reverseOrder());
        	for(int i = 1; i <= countZero; ++i) {
        		arr.add('0');
        	}
        	
        	arr.add(0, '-');
        }
        
        String ans = "";
        for(int i = 0; i < arr.size(); ++i) {
        	ans += arr.get(i);
        }
        
        return Long.valueOf(ans);
        
    }
	
	public static int[] sortEvenOdd(int arr[]) {
		
		ArrayList<Integer> evenArr = new ArrayList<Integer>();
		ArrayList<Integer> oddArr = new ArrayList<Integer>();
 
        for(int i = 0; i < arr.length; i++) {
            if (i % 2 == 0) evenArr.add(arr[i]);
            else oddArr.add(arr[i]);
        }

        Collections.sort(evenArr);
        Collections.sort(oddArr, Collections.reverseOrder());
        
        int i = 0;
        for (int j = 0; j < evenArr.size(); j++) {
            arr[i] = evenArr.get(j);
            i = i + 2;
        }
        
        i = 1;
        for (int j = 0; j < oddArr.size(); j++) {
            arr[i] = oddArr.get(j);
            i = i + 2;
        }
 
        return arr;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-06 09:01:31.027
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-06 09:01:31.027
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-06 09:01:32.231
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package LeetcodeContest;

import java.util.*;

public class weekly279 {

	public static void main(String[] args) {
		int arr[] = {1};
		
		System.out.println(smallestNumber(987654012));
	}
	
	class Bitset {
		
		int size = 0;
		int num;
		
	    public Bitset(int size) {
	        this.size = size;
	        num = 0;
	    }
	    
	    public void fix(int idx) {
	        int temp = 1;
	        temp = temp << idx;
	        num = num | temp;
	    }
	    
	    public void unfix(int idx) {
	    	(n & ~(1 << (k - 1)))
	    }
	    
	    public void flip() {
	        num = ~num;
	    }
	    
	    public boolean all() {
	    	int count = 0;
			for(int i = 0; i <= size; ++i) {
				if((num & 1) == 1) ++count; 
				num = num >> 1;
			}
			
			return count == size;
	    }
	    
	    public boolean one() {
	    	int count = 0;
			for(int i = 0; i <= size; ++i) {
				if((num & 1) == 1) ++count; 
				num = num >> 1;
			}
			
			return count > 0;
	    }
	    
	    public int count() {
	    	int c = 0;
			for(int i = 0; i <= size; ++i) {
				if((num & 1) == 1) ++c; 
				num = num >> 1;
			}
			
			return c;
	    }
	    
	    public String toString() {
	        String s = Integer.toBinaryString(num);
	        return s;
	    }
	}
	
	public static long smallestNumber(long num) {
		if(num == 0) return 0;
        boolean isPos = num > 0;
        
        String s = String.valueOf(num);
        LinkedList<Character> arr = new LinkedList<>();
        int countZero = 0;
        for(int i = 0; i < s.length(); ++i) {
        	if(s.charAt(i) != '0') arr.add(s.charAt(i));
        	else ++countZero;
        }
        
        if(isPos) {
        	Collections.sort(arr);
        	for(int i = 1; i <= countZero; ++i) {
        		arr.add(1, '0');
        	}
        } else {
        	arr.remove(0);
        	Collections.sort(arr, Comparator.reverseOrder());
        	for(int i = 1; i <= countZero; ++i) {
        		arr.add('0');
        	}
        	
        	arr.add(0, '-');
        }
        
        String ans = "";
        for(int i = 0; i < arr.size(); ++i) {
        	ans += arr.get(i);
        }
        
        return Long.valueOf(ans);
        
    }
	
	public static int[] sortEvenOdd(int arr[]) {
		
		ArrayList<Integer> evenArr = new ArrayList<Integer>();
		ArrayList<Integer> oddArr = new ArrayList<Integer>();
 
        for(int i = 0; i < arr.length; i++) {
            if (i % 2 == 0) evenArr.add(arr[i]);
            else oddArr.add(arr[i]);
        }

        Collections.sort(evenArr);
        Collections.sort(oddArr, Collections.reverseOrder());
        
        int i = 0;
        for (int j = 0; j < evenArr.size(); j++) {
            arr[i] = evenArr.get(j);
            i = i + 2;
        }
        
        i = 1;
        for (int j = 0; j < oddArr.size(); j++) {
            arr[i] = oddArr.get(j);
            i = i + 2;
        }
 
        return arr;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-02-06 09:01:32.232
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-02-06 09:01:32.233
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-02-06 09:01:33.528
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package LeetcodeContest;

import java.util.*;

public class weekly279 {

	public static void main(String[] args) {
		int arr[] = {1};
		
		System.out.println(smallestNumber(987654012));
	}
	
	class Bitset {
		
		int size = 0;
		int num;
		
	    public Bitset(int size) {
	        this.size = size;
	        num = 0;
	    }
	    
	    public void fix(int idx) {
	        int temp = 1;
	        temp = temp << idx;
	        num = num | temp;
	    }
	    
	    public void unfix(int idx) {
	    	(n & ~(1 << (k - 1)));
	    }
	    
	    public void flip() {
	        num = ~num;
	    }
	    
	    public boolean all() {
	    	int count = 0;
			for(int i = 0; i <= size; ++i) {
				if((num & 1) == 1) ++count; 
				num = num >> 1;
			}
			
			return count == size;
	    }
	    
	    public boolean one() {
	    	int count = 0;
			for(int i = 0; i <= size; ++i) {
				if((num & 1) == 1) ++count; 
				num = num >> 1;
			}
			
			return count > 0;
	    }
	    
	    public int count() {
	    	int c = 0;
			for(int i = 0; i <= size; ++i) {
				if((num & 1) == 1) ++c; 
				num = num >> 1;
			}
			
			return c;
	    }
	    
	    public String toString() {
	        String s = Integer.toBinaryString(num);
	        return s;
	    }
	}
	
	public static long smallestNumber(long num) {
		if(num == 0) return 0;
        boolean isPos = num > 0;
        
        String s = String.valueOf(num);
        LinkedList<Character> arr = new LinkedList<>();
        int countZero = 0;
        for(int i = 0; i < s.length(); ++i) {
        	if(s.charAt(i) != '0') arr.add(s.charAt(i));
        	else ++countZero;
        }
        
        if(isPos) {
        	Collections.sort(arr);
        	for(int i = 1; i <= countZero; ++i) {
        		arr.add(1, '0');
        	}
        } else {
        	arr.remove(0);
        	Collections.sort(arr, Comparator.reverseOrder());
        	for(int i = 1; i <= countZero; ++i) {
        		arr.add('0');
        	}
        	
        	arr.add(0, '-');
        }
        
        String ans = "";
        for(int i = 0; i < arr.size(); ++i) {
        	ans += arr.get(i);
        }
        
        return Long.valueOf(ans);
        
    }
	
	public static int[] sortEvenOdd(int arr[]) {
		
		ArrayList<Integer> evenArr = new ArrayList<Integer>();
		ArrayList<Integer> oddArr = new ArrayList<Integer>();
 
        for(int i = 0; i < arr.length; i++) {
            if (i % 2 == 0) evenArr.add(arr[i]);
            else oddArr.add(arr[i]);
        }

        Collections.sort(evenArr);
        Collections.sort(oddArr, Collections.reverseOrder());
        
        int i = 0;
        for (int j = 0; j < evenArr.size(); j++) {
            arr[i] = evenArr.get(j);
            i = i + 2;
        }
        
        i = 1;
        for (int j = 0; j < oddArr.size(); j++) {
            arr[i] = oddArr.get(j);
            i = i + 2;
        }
 
        return arr;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-02-06 09:01:33.529
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-02-06 09:01:33.531
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:213)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2022-02-06 10:38:34.334 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-06 10:38:38.874
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-06 10:38:38.874
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-06 10:38:38.874
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-06 10:38:42.282
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-07 14:58:56.985 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-07 14:59:02.520
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-07 14:59:02.520
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-07 14:59:02.520
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-07 14:59:06.250
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-08 10:38:41.743 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-08 10:38:46.309
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-08 10:38:46.309
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-08 10:38:46.309
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-08 10:38:50.994
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-08 22:13:33.502 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-08 22:13:38.333
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-08 22:13:38.333
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-08 22:13:38.333
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-08 22:13:41.589
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-09 10:02:31.870 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-09 10:02:38.913
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-09 10:02:38.914
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-09 10:02:38.914
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-09 10:02:43.626
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-09 15:36:20.308 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-09 15:36:25.434
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-09 15:36:25.434
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-09 15:36:25.434
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-09 15:36:30.011
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-10 14:53:12.264 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-10 14:53:16.823
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-10 14:53:16.823
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-10 14:53:16.823
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-10 14:53:20.075
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-10 22:09:18.581 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-10 22:09:23.293
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-10 22:09:23.294
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-10 22:09:23.294
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-10 22:09:26.649
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-11 22:21:50.999 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-11 22:21:55.959
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-11 22:21:55.959
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-11 22:21:55.959
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-11 22:21:59.260
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-12 13:30:53.259 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-12 13:30:58.790
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-12 13:30:58.790
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-12 13:30:58.790
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-12 13:31:03.031
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-12 21:54:02.269 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-12 21:54:07.044
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-12 21:54:07.044
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@21ea1d9d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-12 21:54:07.044
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-12 21:54:14.866
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-13 08:02:38.646 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-13 08:02:43.846
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-13 08:02:43.846
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-13 08:02:43.846
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-13 08:02:47.685
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-14 21:50:53.401 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-14 21:51:01.178
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-14 21:51:01.178
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-14 21:51:01.178
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-14 21:51:07.133
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-15 22:55:50.204 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-15 22:55:54.961
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-15 22:55:54.961
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-15 22:55:54.961
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-15 22:55:58.091
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-16 10:25:39.835 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-16 10:25:44.783
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-16 10:25:44.783
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-16 10:25:44.783
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-16 10:25:48.418
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-16 15:20:56.805 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-16 15:21:01.698
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-16 15:21:01.698
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-16 15:21:01.698
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-16 15:21:05.293
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-16 22:28:30.771 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-16 22:28:36.529
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-16 22:28:36.529
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54234569,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@21ea1d9d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-16 22:28:36.529
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-16 22:28:40.092
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-19 10:55:36.632 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-19 10:55:41.189
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-19 10:55:41.189
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-19 10:55:41.189
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-19 10:55:44.185
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-19 19:58:03.754 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-19 19:58:08.042
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-19 19:58:08.043
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-19 19:58:08.043
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-19 19:58:11.377
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-19 20:53:53.967 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-19 20:54:02.982
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-19 20:54:02.982
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-19 20:54:02.982
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-19 20:54:07.132
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-19 22:46:28.921 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-19 22:46:33.816
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-19 22:46:33.816
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-19 22:46:33.816
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-19 22:46:37.337
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-20 07:57:53.612 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-20 07:57:58.245
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-20 07:57:58.246
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-20 07:57:58.246
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-20 07:58:01.539
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-20 10:02:52.090 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-20 10:02:56.841
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-20 10:02:56.841
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-20 10:02:56.841
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-20 10:03:00.146
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-21 15:30:49.516 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-21 15:30:56.115
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-21 15:30:56.115
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-21 15:30:56.115
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-21 15:30:59.601
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-22 10:49:08.817 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-22 10:49:14.492
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-22 10:49:14.493
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-22 10:49:14.493
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-22 10:49:19.015
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-22 17:11:39.431 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-22 17:11:43.156
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-22 17:11:43.156
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-22 17:11:43.157
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-22 17:11:46.336
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-24 16:44:37.317 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-24 16:44:42.750
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-24 16:44:42.750
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-24 16:44:42.750
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-24 16:44:46.301
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-24 22:19:49.165 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-24 22:19:53.782
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-24 22:19:53.782
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-24 22:19:53.782
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-24 22:19:56.781
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-24 22:42:10.254 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-24 22:42:14.258
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-24 22:42:14.258
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@21ea1d9d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-24 22:42:14.258
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-24 22:42:17.073
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-25 11:33:28.193 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-25 11:33:33.261
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-25 11:33:33.261
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-25 11:33:33.261
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-25 11:33:36.941
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-02-27 08:01:12.308 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-02-27 08:01:18.712
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-27 08:01:18.712
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-02-27 08:01:18.712
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-02-27 08:01:23.260
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-02 17:19:16.130 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-02 17:19:20.744
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-02 17:19:20.744
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-02 17:19:20.744
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-02 17:19:24.138
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-02 22:29:32.695 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-02 22:29:37.223
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-02 22:29:37.223
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-02 22:29:37.223
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-02 22:29:40.517
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-03 21:20:57.677 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-03 21:21:02.281
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-03 21:21:02.281
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-03 21:21:02.281
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-03 21:21:05.583
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-04 09:31:34.016 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-04 09:31:39.695
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-04 09:31:39.695
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-04 09:31:39.695
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-04 09:31:43.652
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2022-03-04 23:22:33.528
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Error in Java Model (code 969): minimumElements2Helper(int, int[], int) [in DynamicProgramming2 [in [Working copy] DynamicProgramming2.java [in dynamicProgramming [in src [in DSA]]]]] does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:617)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:328)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:314)
	at org.eclipse.jdt.internal.core.SourceRefElement.getSourceRange(SourceRefElement.java:233)
	at org.eclipse.jdt.internal.core.Member.getJavadocRange(Member.java:301)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:639)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:515)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:748)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2022-03-04 23:22:33.531
!MESSAGE minimumElements2Helper(int, int[], int) [in DynamicProgramming2 [in [Working copy] DynamicProgramming2.java [in dynamicProgramming [in src [in DSA]]]]] does not exist
!SESSION 2022-03-05 10:27:48.318 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-05 10:27:53.101
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-05 10:27:53.102
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-05 10:27:53.102
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-05 10:27:56.371
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-03-05 12:21:11.222
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package Chegg;

import java.util.*;

public class Chegg6 {

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);
//		int n = sc.nextInt();
//		int arr[] = new int[n];
//		for (int i = 0; i < n; ++i) {
//			arr[i] = sc.nextInt();
//		}
//		sc.close();
//		System.out.println(solve(arr));
		
		System.out.println(782%3);

	}
	
	for(int i = 0; i < size; ++i) {
		if(i == indexValue) {
			continue;
		} else {
			cout << inputList
		}
	}
	
	public static int f(int num) {
		
		int count = 0;
	    while(num > 0) {
	        ++count;
	        num /= 10;
	    }
		
	    return num%count;
	    
	}

	public static int solve(int arr[]) {

		int cnt = 0;
		int n = arr.length;

		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n; j++) {
				for (int k = j + 1; k < n; k++) {

					if (arr[k] < arr[i] && arr[i] < arr[j]) {
						Set<Integer> s1 = new HashSet<>();
						Set<Integer> s2 = new HashSet<>();
						Set<Integer> s3 = new HashSet<>();
						
						int tmp = 0;
						while (arr[i] > 0) {
							tmp = arr[i] % 10;
							s1.add(tmp);
							arr[i] /= 10;
						}
						
						tmp = 0;
						while (arr[j] > 0) {
							tmp = arr[j] % 10;
							s2.add(tmp);
							arr[j] /= 10;
						}
						
						tmp = 0;
						while (arr[k] > 0) {
							tmp = arr[k] % 10;
							s3.add(tmp);
							arr[k] /= 10;
						}
						
						System.out.println(s1);
						System.out.println(s2);
						System.out.println(s3);
						
						s1.retainAll(s2);
						s1.retainAll(s3);
					
						if(s1.size() > 1) ++cnt;
					}
				}
			}
		}

		return cnt;

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:526)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-03-05 12:21:11.223
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:526)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-03-05 12:21:11.224
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:526)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2022-03-05 16:20:38.122 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-05 16:20:43.039
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-05 16:20:43.039
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-05 16:20:43.039
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-05 16:20:46.755
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-05 16:26:39.776 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-05 16:26:45.027
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-05 16:26:45.027
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-05 16:26:45.027
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-05 16:26:48.268
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-05 23:54:28.894 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-05 23:54:33.490
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-05 23:54:33.490
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-05 23:54:33.490
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-05 23:54:36.934
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-06 00:31:44.270 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-06 00:31:48.591
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-06 00:31:48.591
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ceb68a1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-06 00:31:48.591
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6de33fde,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69c33ea2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-06 00:31:51.757
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-06 11:35:56.601 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-06 11:36:01.356
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-06 11:36:01.356
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2efcc0b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-06 11:36:01.356
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-06 11:36:04.727
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-06 15:08:53.916 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-06 15:08:57.649
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-06 15:08:57.649
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@21ea1d9d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-06 15:08:57.649
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-06 15:09:01.014
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.debug.core 4 125 2022-03-06 18:51:30.153
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at org.eclipse.debug.internal.core.InputStreamMonitor.writeNext(InputStreamMonitor.java:183)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:163)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.debug.core 4 125 2022-03-06 18:51:30.262
!MESSAGE Error logged from Debug Core: 
!STACK 0
java.io.IOException: The pipe is being closed
	at java.base/java.io.FileOutputStream.writeBytes(Native Method)
	at java.base/java.io.FileOutputStream.write(FileOutputStream.java:349)
	at java.base/java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:81)
	at java.base/java.io.BufferedOutputStream.flush(BufferedOutputStream.java:142)
	at java.base/java.io.FilterOutputStream.close(FilterOutputStream.java:182)
	at org.eclipse.debug.internal.core.InputStreamMonitor.write(InputStreamMonitor.java:167)
	at java.base/java.lang.Thread.run(Thread.java:833)
!SESSION 2022-03-06 21:15:13.304 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-06 21:15:17.228
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-06 21:15:17.228
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-06 21:15:17.228
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ceb68a1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-06 21:15:20.480
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-07 21:29:37.877 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-07 21:29:44.499
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-07 21:29:44.499
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-07 21:29:44.499
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ceb68a1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6de33fde,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-07 21:29:48.344
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-08 00:12:19.575 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-08 00:12:24.844
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-08 00:12:24.844
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ceb68a1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6de33fde,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-08 00:12:24.844
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69c33ea2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59e0d521,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-08 00:12:28.512
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-08 00:22:47.157 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-08 00:22:50.823
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-08 00:22:50.823
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5b0e9e0c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54234569,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-08 00:22:50.823
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@21ea1d9d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-08 00:22:54.462
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-08 11:18:09.881 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-08 11:18:14.294
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-08 11:18:14.294
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-08 11:18:14.294
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3460e4ed,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-08 11:18:17.514
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-08 21:34:22.010 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-08 21:34:26.855
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-08 21:34:26.855
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-08 21:34:26.855
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-08 21:34:30.201
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-09 21:37:23.956 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-09 21:37:30.412
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-09 21:37:30.412
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-09 21:37:30.412
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ceb68a1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6de33fde,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-09 21:37:35.918
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-10 13:58:09.600 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-10 13:58:14.522
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-10 13:58:14.523
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54234569,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@21ea1d9d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-10 13:58:14.523
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-10 13:58:18.914
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-13 18:35:16.666 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-13 18:35:22.068
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-13 18:35:22.068
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@21ea1d9d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-13 18:35:22.068
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-13 18:35:26.786
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-13 22:25:59.124 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-13 22:26:05.031
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-13 22:26:05.031
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54234569,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@21ea1d9d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-13 22:26:05.031
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-13 22:26:09.045
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-14 10:00:28.257 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-14 10:00:37.005
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-14 10:00:37.005
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-14 10:00:37.005
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-14 10:00:41.163
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-16 10:41:55.676 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2022-03-16 10:41:57.630
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2022-03-16 10:42:02.804
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-16 10:42:02.804
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@40863800,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5950054d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-16 10:42:02.804
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24018c8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-16 10:42:06.203
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-16 10:54:31.996 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-16 10:54:36.991
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-16 10:54:36.991
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19f497aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36a58466,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-16 10:54:36.991
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78e387d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9147ba2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-16 10:54:40.442
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-16 17:23:31.630 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2022-03-16 17:23:33.660
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2022-03-16 17:23:36.528
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-16 17:23:36.528
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@17befef0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5072e638,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-16 17:23:36.528
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3129299f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f73f0c7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-16 17:23:39.882
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-20 12:55:09.625 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-20 12:55:14.629
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-20 12:55:14.629
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-20 12:55:14.629
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ceb68a1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-20 12:55:18.503
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-21 09:05:17.461 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-21 09:05:21.598
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-21 09:05:21.598
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6de33fde,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69c33ea2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-21 09:05:21.598
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59e0d521,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2e3900dc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-21 09:05:24.962
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-03-21 10:14:38.424
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package SheetSDE;

import java.util.*;

public class Day1 {

	public static void main(String[] args) {
	
		
		int arr[][] = {{1, 1, 1}, {1, 0, 1}, {1, 1, 1}};
		setZeroes(arr);
		for(int i = 0; i < arr.length; ++i) System.out.println(Arrays.toString(arr[i]));
		
	}
	
	/* ------------------------------------------------------------------ */

	public static void nextPermutation(int[] nums) {
		
		int n = nums.length;
		if(n == 1) return;
		
		int k = -1;
		for(int i = n - 2; i >= 0; --i) {
			if(nums[i] < nums[i + 1]) {
				k = i;
				break;
			}
		}
		
		if(k == -1) 
		
		for(int i = n - 1; i >= 0; --i) {
			if(nums[i] > nums[k]) {
				swapArr(nums, i, k);
				break;
			}
		}
		
		
		int j = n - 1;
		while(k < j) {
			swapArr(nums, k, j);
			++k;
			--j;
		}
 		
	}
	
	public static void reverseSubarray(int arr[])
	
	public static void swapArr(int arr[], int i, int j) {
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
	
	/* ------------------------------------------------------------------ */
	
	// Brute : works only if matrix[i][j] >= 0. 
	public static void setZeroes1(int[][] matrix) {
		
		for(int i = 0; i < matrix.length; ++i) {
			for(int j = 0; j < matrix[0].length; ++j) {
				if(matrix[i][j] == 0) {
					for(int p = 0; p < matrix.length; ++p) 
						if(matrix[p][j] != 0) matrix[p][j] = -1;
					for(int p = 0; p < matrix[0].length; ++p) 
						if(matrix[i][p] != 0) matrix[i][p] = -1;
				}
			}
		}
		
		for(int i = 0; i < matrix.length; ++i) {
			for(int j = 0; j < matrix[0].length; ++j) {
				if(matrix[i][j] == -1) matrix[i][j] = 0;
			}
		}
	}
	
	// Better
	public static void setZeroes2(int[][] matrix) {
		
		int row[] = new int[matrix[0].length];
		int col[] = new int[matrix.length];
		
		for(int i = 0; i < matrix.length; ++i) {
			for(int j = 0; j < matrix[0].length; ++j) {
				if(matrix[i][j] == 0) row[j] = col[i] = -1;
			}
		}
		
		for(int i = 0; i < matrix.length; ++i) {
			for(int j = 0; j < matrix[0].length; ++j) {
				if(row[j] == -1 || col[i] == -1) matrix[i][j] = 0;
			}
		}
	}
	
	// Optimal
	public static void setZeroes3(int[][] matrix) {
		
		int col0 = 1;
		
		for(int i = 0; i < matrix.length; ++i) {
			if(matrix[i][0] == 0) col0 = 0;
			for(int j = 1; j < matrix[0].length; ++j) {
				if(matrix[i][j] == 0) matrix[0][j] = matrix[i][0] = 0;
			}
		}
		
		for(int i = matrix.length - 1; i >= 0; --i) {
			for(int j = matrix[0].length - 1; j >= 1; --j)
				if(matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;
			
			if(col0 == 0) matrix[i][0] = 0;
		}
		
	}
	
	
	// My
	public static void setZeroes(int[][] matrix) {
		
		HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();
		
		for(int i = 0; i < matrix.length; ++i) {
			map.putIfAbsent(i, new ArrayList<>());
			for(int j = 0; j < matrix[0].length; ++j) if(matrix[i][j] == 0) map.get(i).add(j);
		}
		
		for(int i = 0; i < matrix.length; ++i) {
			ArrayList<Integer> curr = map.get(i);
			for(int j = 0; j < curr.size(); ++j) setZeroesHelper(i, curr.get(j), matrix);
		}
		
	}
	
	public static void setZeroesHelper(int i, int j, int[][] matrix) {
		for(int p = 0; p < matrix.length; ++p) matrix[p][j] = 0;
		for(int p = 0; p < matrix[0].length; ++p) matrix[i][p] = 0;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-03-21 10:14:38.436
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-03-21 10:14:38.437
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-03-21 10:14:41.961
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package SheetSDE;

import java.util.*;

public class Day1 {

	public static void main(String[] args) {
	
		
		int arr[][] = {{1, 1, 1}, {1, 0, 1}, {1, 1, 1}};
		setZeroes(arr);
		for(int i = 0; i < arr.length; ++i) System.out.println(Arrays.toString(arr[i]));
		
	}
	
	/* ------------------------------------------------------------------ */

	public static void nextPermutation(int[] nums) {
		
		int n = nums.length;
		if(n == 1) return;
		
		int k = -1;
		for(int i = n - 2; i >= 0; --i) {
			if(nums[i] < nums[i + 1]) {
				k = i;
				break;
			}
		}
		
		if(k == -1) 
		
		for(int i = n - 1; i >= 0; --i) {
			if(nums[i] > nums[k]) {
				swapArr(nums, i, k);
				break;
			}
		}
		
		
		int j = n - 1;
		while(k < j) {
			swapArr(nums, k, j);
			++k;
			--j;
		}
 		
	}
	
	public static void reverseSubarray(int arr[], int i, int )
	
	public static void swapArr(int arr[], int i, int j) {
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
	
	/* ------------------------------------------------------------------ */
	
	// Brute : works only if matrix[i][j] >= 0. 
	public static void setZeroes1(int[][] matrix) {
		
		for(int i = 0; i < matrix.length; ++i) {
			for(int j = 0; j < matrix[0].length; ++j) {
				if(matrix[i][j] == 0) {
					for(int p = 0; p < matrix.length; ++p) 
						if(matrix[p][j] != 0) matrix[p][j] = -1;
					for(int p = 0; p < matrix[0].length; ++p) 
						if(matrix[i][p] != 0) matrix[i][p] = -1;
				}
			}
		}
		
		for(int i = 0; i < matrix.length; ++i) {
			for(int j = 0; j < matrix[0].length; ++j) {
				if(matrix[i][j] == -1) matrix[i][j] = 0;
			}
		}
	}
	
	// Better
	public static void setZeroes2(int[][] matrix) {
		
		int row[] = new int[matrix[0].length];
		int col[] = new int[matrix.length];
		
		for(int i = 0; i < matrix.length; ++i) {
			for(int j = 0; j < matrix[0].length; ++j) {
				if(matrix[i][j] == 0) row[j] = col[i] = -1;
			}
		}
		
		for(int i = 0; i < matrix.length; ++i) {
			for(int j = 0; j < matrix[0].length; ++j) {
				if(row[j] == -1 || col[i] == -1) matrix[i][j] = 0;
			}
		}
	}
	
	// Optimal
	public static void setZeroes3(int[][] matrix) {
		
		int col0 = 1;
		
		for(int i = 0; i < matrix.length; ++i) {
			if(matrix[i][0] == 0) col0 = 0;
			for(int j = 1; j < matrix[0].length; ++j) {
				if(matrix[i][j] == 0) matrix[0][j] = matrix[i][0] = 0;
			}
		}
		
		for(int i = matrix.length - 1; i >= 0; --i) {
			for(int j = matrix[0].length - 1; j >= 1; --j)
				if(matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;
			
			if(col0 == 0) matrix[i][0] = 0;
		}
		
	}
	
	
	// My
	public static void setZeroes(int[][] matrix) {
		
		HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();
		
		for(int i = 0; i < matrix.length; ++i) {
			map.putIfAbsent(i, new ArrayList<>());
			for(int j = 0; j < matrix[0].length; ++j) if(matrix[i][j] == 0) map.get(i).add(j);
		}
		
		for(int i = 0; i < matrix.length; ++i) {
			ArrayList<Integer> curr = map.get(i);
			for(int j = 0; j < curr.size(); ++j) setZeroesHelper(i, curr.get(j), matrix);
		}
		
	}
	
	public static void setZeroesHelper(int i, int j, int[][] matrix) {
		for(int p = 0; p < matrix.length; ++p) matrix[p][j] = 0;
		for(int p = 0; p < matrix[0].length; ++p) matrix[i][p] = 0;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-03-21 10:14:41.962
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-03-21 10:14:41.963
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3263)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:738)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2022-03-21 21:20:42.223 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-21 21:20:47.026
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-21 21:20:47.026
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-21 21:20:47.026
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ceb68a1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-21 21:20:50.546
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 4 2022-03-22 22:13:52.312
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:683)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:275)
	at org.eclipse.jface.resource.DeferredImageDescriptor.createImage(DeferredImageDescriptor.java:80)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:97)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:72)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImage(ResourceManager.java:175)
	at org.eclipse.ui.actions.OpenWithMenu.getImage(OpenWithMenu.java:136)
	at org.eclipse.ui.actions.OpenWithMenu.createMenuItem(OpenWithMenu.java:173)
	at org.eclipse.ui.actions.OpenWithMenu.fill(OpenWithMenu.java:270)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4779)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:228)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:294)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:304)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1076)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1014)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:379)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5150)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4782)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5002)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4101)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SESSION 2022-03-22 22:35:37.548 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-22 22:35:42.073
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-22 22:35:42.073
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-22 22:35:42.073
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ceb68a1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6de33fde,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-22 22:35:45.210
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-03-23 10:39:10.212 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-03-23 10:39:14.565
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-23 10:39:14.565
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4a453f8d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-03-23 10:39:14.565
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-03-23 10:39:17.940
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Ayush'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
